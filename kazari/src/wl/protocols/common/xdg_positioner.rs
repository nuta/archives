//! The xdg_positioner provides a collection of rules for the placement of a child
//! surface relative to a parent surface. rules can be defined to ensure the child
//! surface remains within the visible area's borders, and to specify how the child
//! surface changes its position, such as sliding along an axis, or flipping around
//! a rectangle. these positioner-created rules are constrained by the requirement
//! that a child surface must intersect with or be at least partially adjacent to
//! its parent surface. see the various requests for details about possible rules.
//! at the time of the request, the compositor makes a copy of the rules specified
//! by the xdg_positioner. thus, after the request is complete the xdg_positioner
//! object can be destroyed or reused; further changes to the object will have no
//! effect on previous usages. for an xdg_positioner object to be considered
//! complete, it must have a non-zero size set by set_size, and a non-zero anchor
//! rectangle set by set_anchor_rect. passing an incomplete xdg_positioner object
//! when positioning a surface raises an error.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;

use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// Notify the compositor that the xdg_positioner will no longer be used.
    Destroy {},
    /// Set the size of the surface that is to be positioned with the positioner object.
    /// the size is in surface-local coordinates and corresponds to the window geometry.
    /// see xdg_surface.set_window_geometry. if a zero or negative size is set the
    /// invalid_input error is raised.
    SetSize {
        /// Width of positioned rectangle.
        width: i32,
        /// Height of positioned rectangle.
        height: i32,
    },
    /// Specify the anchor rectangle within the parent surface that the child surface
    /// will be placed relative to. the rectangle is relative to the window geometry as
    /// defined by xdg_surface.set_window_geometry of the parent surface. when the
    /// xdg_positioner object is used to position a child surface, the anchor rectangle
    /// may not extend outside the window geometry of the positioned child's parent
    /// surface. if a negative size is set the invalid_input error is raised.
    SetAnchorRect {
        /// X position of anchor rectangle.
        x: i32,
        /// Y position of anchor rectangle.
        y: i32,
        /// Width of anchor rectangle.
        width: i32,
        /// Height of anchor rectangle.
        height: i32,
    },
    /// Defines the anchor point for the anchor rectangle. the specified anchor is used
    /// derive an anchor point that the child surface will be positioned relative to. if
    /// a corner anchor is set (e.g. 'top_left' or 'bottom_right'), the anchor point
    /// will be at the specified corner; otherwise, the derived anchor point will be
    /// centered on the specified edge, or in the center of the anchor rectangle if no
    /// edge is specified.
    SetAnchor {
        /// Anchor.
        anchor: Anchor,
    },
    /// Defines in what direction a surface should be positioned, relative to the anchor
    /// point of the parent surface. if a corner gravity is specified (e.g.
    /// 'bottom_right' or 'top_left'), then the child surface will be placed towards the
    /// specified gravity; otherwise, the child surface will be centered over the anchor
    /// point on any axis that had no gravity specified.
    SetGravity {
        /// Gravity direction.
        gravity: Gravity,
    },
    /// Specify how the window should be positioned if the originally intended position
    /// caused the surface to be constrained, meaning at least partially outside
    /// positioning boundaries set by the compositor. the adjustment is set by
    /// constructing a bitmask describing the adjustment to be made when the surface is
    /// constrained on that axis. if no bit for one axis is set, the compositor will
    /// assume that the child surface should not change its position on that axis when
    /// constrained. if more than one bit for one axis is set, the order of how
    /// adjustments are applied is specified in the corresponding adjustment
    /// descriptions. the default adjustment is none.
    SetConstraintAdjustment {
        /// Bit mask of constraint adjustments.
        constraint_adjustment: u32,
    },
    /// Specify the surface position offset relative to the position of the anchor on
    /// the anchor rectangle and the anchor on the surface. for example if the anchor of
    /// the anchor rectangle is at (x, y), the surface has the gravity bottom|right, and
    /// the offset is (ox, oy), the calculated surface position will be (x + ox, y +
    /// oy). the offset position of the surface is the one used for constraint testing.
    /// see set_constraint_adjustment. an example use case is placing a popup menu on
    /// top of a user interface element, while aligning the user interface element of
    /// the parent surface with some user interface element placed somewhere in the
    /// popup surface.
    SetOffset {
        /// Surface position x offset.
        x: i32,
        /// Surface position y offset.
        y: i32,
    },
    /// When set reactive, the surface is reconstrained if the conditions used for
    /// constraining changed, e.g. the parent window moved. if the conditions changed
    /// and the popup was reconstrained, an xdg_popup.configure event is sent with
    /// updated geometry, followed by an xdg_surface.configure event.
    SetReactive {},
    /// Set the parent window geometry the compositor should use when positioning the
    /// popup. the compositor may use this information to determine the future state the
    /// popup should be constrained using. if this doesn't match the dimension of the
    /// parent the popup is eventually positioned against, the behavior is undefined.
    /// the arguments are given in the surface-local coordinate space.
    SetParentSize {
        /// Future window geometry width of parent.
        parent_width: i32,
        /// Future window geometry height of parent.
        parent_height: i32,
    },
    /// Set the serial of an xdg_surface.configure event this positioner will be used in
    /// response to. the compositor may use this information together with
    /// set_parent_size to determine what future state the popup should be constrained
    /// using.
    SetParentConfigure {
        /// Serial of parent configure event.
        serial: u32,
    },
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::Destroy {} => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![],
            },
            Request::SetSize { width, height } => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![width.into(), height.into()],
            },
            Request::SetAnchorRect {
                x,
                y,
                width,
                height,
            } => RawMessage {
                sender,
                opcode: Opcode(3),
                args: smallvec![x.into(), y.into(), width.into(), height.into()],
            },
            Request::SetAnchor { anchor } => RawMessage {
                sender,
                opcode: Opcode(4),
                args: smallvec![anchor.into()],
            },
            Request::SetGravity { gravity } => RawMessage {
                sender,
                opcode: Opcode(5),
                args: smallvec![gravity.into()],
            },
            Request::SetConstraintAdjustment {
                constraint_adjustment,
            } => RawMessage {
                sender,
                opcode: Opcode(6),
                args: smallvec![constraint_adjustment.into()],
            },
            Request::SetOffset { x, y } => RawMessage {
                sender,
                opcode: Opcode(7),
                args: smallvec![x.into(), y.into()],
            },
            Request::SetReactive {} => RawMessage {
                sender,
                opcode: Opcode(8),
                args: smallvec![],
            },
            Request::SetParentSize {
                parent_width,
                parent_height,
            } => RawMessage {
                sender,
                opcode: Opcode(9),
                args: smallvec![parent_width.into(), parent_height.into()],
            },
            Request::SetParentConfigure { serial } => RawMessage {
                sender,
                opcode: Opcode(10),
                args: smallvec![serial.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::Destroy {}),
            Opcode(2) => Ok(Request::SetSize {
                width: from_payload!(Int, m.args[0]),

                height: from_payload!(Int, m.args[1]),
            }),
            Opcode(3) => Ok(Request::SetAnchorRect {
                x: from_payload!(Int, m.args[0]),

                y: from_payload!(Int, m.args[1]),

                width: from_payload!(Int, m.args[2]),

                height: from_payload!(Int, m.args[3]),
            }),
            Opcode(4) => Ok(Request::SetAnchor {
                anchor: from_payload!(UInt, m.args[0]),
            }),
            Opcode(5) => Ok(Request::SetGravity {
                gravity: from_payload!(UInt, m.args[0]),
            }),
            Opcode(6) => Ok(Request::SetConstraintAdjustment {
                constraint_adjustment: from_payload!(UInt, m.args[0]),
            }),
            Opcode(7) => Ok(Request::SetOffset {
                x: from_payload!(Int, m.args[0]),

                y: from_payload!(Int, m.args[1]),
            }),
            Opcode(8) => Ok(Request::SetReactive {}),
            Opcode(9) => Ok(Request::SetParentSize {
                parent_width: from_payload!(Int, m.args[0]),

                parent_height: from_payload!(Int, m.args[1]),
            }),
            Opcode(10) => Ok(Request::SetParentConfigure {
                serial: from_payload!(UInt, m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::XdgPositioner(self)
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Error {
    /// Invalid input provided.
    InvalidInput = 0,
}

impl Into<Payload> for Error {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Error {
    fn from(value: u32) -> Error {
        match value {
            0 => Error::InvalidInput,

            _ => unreachable!(),
        }
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Anchor {
    /// (no document).
    None = 0,
    /// (no document).
    Top = 1,
    /// (no document).
    Bottom = 2,
    /// (no document).
    Left = 3,
    /// (no document).
    Right = 4,
    /// (no document).
    TopLeft = 5,
    /// (no document).
    BottomLeft = 6,
    /// (no document).
    TopRight = 7,
    /// (no document).
    BottomRight = 8,
}

impl Into<Payload> for Anchor {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Anchor {
    fn from(value: u32) -> Anchor {
        match value {
            0 => Anchor::None,
            1 => Anchor::Top,
            2 => Anchor::Bottom,
            3 => Anchor::Left,
            4 => Anchor::Right,
            5 => Anchor::TopLeft,
            6 => Anchor::BottomLeft,
            7 => Anchor::TopRight,
            8 => Anchor::BottomRight,

            _ => unreachable!(),
        }
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Gravity {
    /// (no document).
    None = 0,
    /// (no document).
    Top = 1,
    /// (no document).
    Bottom = 2,
    /// (no document).
    Left = 3,
    /// (no document).
    Right = 4,
    /// (no document).
    TopLeft = 5,
    /// (no document).
    BottomLeft = 6,
    /// (no document).
    TopRight = 7,
    /// (no document).
    BottomRight = 8,
}

impl Into<Payload> for Gravity {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Gravity {
    fn from(value: u32) -> Gravity {
        match value {
            0 => Gravity::None,
            1 => Gravity::Top,
            2 => Gravity::Bottom,
            3 => Gravity::Left,
            4 => Gravity::Right,
            5 => Gravity::TopLeft,
            6 => Gravity::BottomLeft,
            7 => Gravity::TopRight,
            8 => Gravity::BottomRight,

            _ => unreachable!(),
        }
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ConstraintAdjustment {
    /// (no document).
    None = 0,
    /// (no document).
    SlideX = 1,
    /// (no document).
    SlideY = 2,
    /// (no document).
    FlipX = 4,
    /// (no document).
    FlipY = 8,
    /// (no document).
    ResizeX = 16,
    /// (no document).
    ResizeY = 32,
}

impl Into<Payload> for ConstraintAdjustment {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for ConstraintAdjustment {
    fn from(value: u32) -> ConstraintAdjustment {
        match value {
            0 => ConstraintAdjustment::None,
            1 => ConstraintAdjustment::SlideX,
            2 => ConstraintAdjustment::SlideY,
            4 => ConstraintAdjustment::FlipX,
            8 => ConstraintAdjustment::FlipY,
            16 => ConstraintAdjustment::ResizeX,
            32 => ConstraintAdjustment::ResizeY,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {}
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::XdgPositioner(XdgPositioner::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Child surface positioner.
#[derive(Clone)]
pub struct XdgPositioner {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for XdgPositioner {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for XdgPositioner {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "XdgPositioner@{}", self.object_id.0)
    }
}

impl Into<Payload> for XdgPositioner {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for XdgPositioner {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "xdg_positioner";
    const VERSION: u32 = 3;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[],
        &[PayloadType::Int, PayloadType::Int],
        &[
            PayloadType::Int,
            PayloadType::Int,
            PayloadType::Int,
            PayloadType::Int,
        ],
        &[PayloadType::UInt],
        &[PayloadType::UInt],
        &[PayloadType::UInt],
        &[PayloadType::Int, PayloadType::Int],
        &[],
        &[PayloadType::Int, PayloadType::Int],
        &[PayloadType::UInt],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> XdgPositioner {
        XdgPositioner { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
