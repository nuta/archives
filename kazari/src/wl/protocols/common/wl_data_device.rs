//! There is one wl_data_device per seat which can be obtained from the global
//! wl_data_device_manager singleton. a wl_data_device provides access to inter-
//! client data transfer mechanisms such as copy-and-paste and drag-and-drop.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;

use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// This request asks the compositor to start a drag-and-drop operation on behalf of
    /// the client. the source argument is the data source that provides the data for
    /// the eventual data transfer. if source is null, enter, leave and motion events
    /// are sent only to the client that initiated the drag and the client is expected
    /// to handle the data passing internally. if source is destroyed, the drag-and-drop
    /// session will be cancelled. the origin surface is the surface where the drag
    /// originates and the client must have an active implicit grab that matches the
    /// serial. the icon surface is an optional (can be null) surface that provides an
    /// icon to be moved around with the cursor. initially, the top-left corner of the
    /// icon surface is placed at the cursor hotspot, but subsequent wl_surface.attach
    /// request can move the relative position. attach requests must be confirmed with
    /// wl_surface.commit as usual. the icon surface is given the role of a drag-and-
    /// drop icon. if the icon surface already has another role, it raises a protocol
    /// error. the current and pending input regions of the icon wl_surface are cleared,
    /// and wl_surface.set_input_region is ignored until the wl_surface is no longer
    /// used as the icon surface. when the use as an icon ends, the current and pending
    /// input regions become undefined, and the wl_surface is unmapped.
    StartDrag {
        /// Data source for the eventual transfer.
        source: Option<WlDataSource>,
        /// Surface where the drag originates.
        origin: WlSurface,
        /// Drag-and-drop icon surface.
        icon: Option<WlSurface>,
        /// Serial number of the implicit grab on the origin.
        serial: u32,
    },
    /// This request asks the compositor to set the selection to the data from the
    /// source on behalf of the client. to unset the selection, set the source to null.
    SetSelection {
        /// Data source for the selection.
        source: Option<WlDataSource>,
        /// Serial number of the event that triggered this request.
        serial: u32,
    },
    /// This request destroys the data device.
    Release {},
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::StartDrag {
                source,
                origin,
                icon,
                serial,
            } => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![source.into(), origin.into(), icon.into(), serial.into()],
            },
            Request::SetSelection { source, serial } => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![source.into(), serial.into()],
            },
            Request::Release {} => RawMessage {
                sender,
                opcode: Opcode(3),
                args: smallvec![],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::StartDrag {
                source: from_optional_object_payload!(WlDataSource, con.clone(), m.args[0]),

                origin: from_object_payload!(WlSurface, con.clone(), m.args[1]),

                icon: from_optional_object_payload!(WlSurface, con.clone(), m.args[2]),

                serial: from_payload!(UInt, m.args[3]),
            }),
            Opcode(2) => Ok(Request::SetSelection {
                source: from_optional_object_payload!(WlDataSource, con.clone(), m.args[0]),

                serial: from_payload!(UInt, m.args[1]),
            }),
            Opcode(3) => Ok(Request::Release {}),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::WlDataDevice(self)
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Error {
    /// Given wl_surface has another role.
    Role = 0,
}

impl Into<Payload> for Error {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Error {
    fn from(value: u32) -> Error {
        match value {
            0 => Error::Role,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {
    /// The data_offer event introduces a new wl_data_offer object, which will
    /// subsequently be used in either the data_device.enter event (for drag-and-drop)
    /// or the data_device.selection event (for selections). immediately following the
    /// data_device_data_offer event, the new data_offer object will send out
    /// data_offer.offer events to describe the mime types it offers.
    DataOffer {
        /// The new data_offer object.
        id: NewId,
    },
    /// This event is sent when an active drag-and-drop pointer enters a surface owned
    /// by the client. the position of the pointer at enter time is provided by the x
    /// and y arguments, in surface-local coordinates.
    Enter {
        /// Serial number of the enter event.
        serial: u32,
        /// Client surface entered.
        surface: WlSurface,
        /// Surface-local x coordinate.
        x: f32,
        /// Surface-local y coordinate.
        y: f32,
        /// Source data_offer object.
        id: Option<WlDataOffer>,
    },
    /// This event is sent when the drag-and-drop pointer leaves the surface and the
    /// session ends. the client must destroy the wl_data_offer introduced at enter time
    /// at this point.
    Leave {},
    /// This event is sent when the drag-and-drop pointer moves within the currently
    /// focused surface. the new position of the pointer is provided by the x and y
    /// arguments, in surface-local coordinates.
    Motion {
        /// Timestamp with millisecond granularity.
        time: u32,
        /// Surface-local x coordinate.
        x: f32,
        /// Surface-local y coordinate.
        y: f32,
    },
    /// The event is sent when a drag-and-drop operation is ended because the implicit
    /// grab is removed. the drag-and-drop destination is expected to honor the last
    /// action received through wl_data_offer.action, if the resulting action is "copy"
    /// or "move", the destination can still perform wl_data_offer.receive requests, and
    /// is expected to end all transfers with a wl_data_offer.finish request. if the
    /// resulting action is "ask", the action will not be considered final. the drag-
    /// and-drop destination is expected to perform one last wl_data_offer.set_actions
    /// request, or wl_data_offer.destroy in order to cancel the operation.
    Drop {},
    /// The selection event is sent out to notify the client of a new wl_data_offer for
    /// the selection for this device. the data_device.data_offer and the
    /// data_offer.offer events are sent out immediately before this event to introduce
    /// the data offer object. the selection event is sent to a client immediately
    /// before receiving keyboard focus and when a new selection is set while the client
    /// has keyboard focus. the data_offer is valid until a new data_offer or null is
    /// received or until the client loses keyboard focus. the client must destroy the
    /// previous selection data_offer, if any, upon receiving this event.
    Selection {
        /// Selection data_offer object.
        id: Option<WlDataOffer>,
    },
}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Event::DataOffer { id } => RawMessage {
                sender,
                opcode: Opcode(4),
                args: smallvec![id.into()],
            },
            Event::Enter {
                serial,
                surface,
                x,
                y,
                id,
            } => RawMessage {
                sender,
                opcode: Opcode(5),
                args: smallvec![serial.into(), surface.into(), x.into(), y.into(), id.into()],
            },
            Event::Leave {} => RawMessage {
                sender,
                opcode: Opcode(6),
                args: smallvec![],
            },
            Event::Motion { time, x, y } => RawMessage {
                sender,
                opcode: Opcode(7),
                args: smallvec![time.into(), x.into(), y.into()],
            },
            Event::Drop {} => RawMessage {
                sender,
                opcode: Opcode(8),
                args: smallvec![],
            },
            Event::Selection { id } => RawMessage {
                sender,
                opcode: Opcode(9),
                args: smallvec![id.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            Opcode(4) => Ok(Event::DataOffer {
                id: from_payload!(NewId, m.args[0]),
            }),
            Opcode(5) => Ok(Event::Enter {
                serial: from_payload!(UInt, m.args[0]),

                surface: from_object_payload!(WlSurface, con.clone(), m.args[1]),

                x: from_payload!(Fixed, m.args[2]),

                y: from_payload!(Fixed, m.args[3]),

                id: from_optional_object_payload!(WlDataOffer, con.clone(), m.args[4]),
            }),
            Opcode(6) => Ok(Event::Leave {}),
            Opcode(7) => Ok(Event::Motion {
                time: from_payload!(UInt, m.args[0]),

                x: from_payload!(Fixed, m.args[1]),

                y: from_payload!(Fixed, m.args[2]),
            }),
            Opcode(8) => Ok(Event::Drop {}),
            Opcode(9) => Ok(Event::Selection {
                id: from_optional_object_payload!(WlDataOffer, con.clone(), m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::WlDataDevice(WlDataDevice::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Data transfer device.
#[derive(Clone)]
pub struct WlDataDevice {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for WlDataDevice {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for WlDataDevice {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "WlDataDevice@{}", self.object_id.0)
    }
}

impl Into<Payload> for WlDataDevice {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for WlDataDevice {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "wl_data_device";
    const VERSION: u32 = 3;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[
            PayloadType::ObjectId,
            PayloadType::ObjectId,
            PayloadType::ObjectId,
            PayloadType::UInt,
        ],
        &[PayloadType::ObjectId, PayloadType::UInt],
        &[],
        &[PayloadType::NewId],
        &[
            PayloadType::UInt,
            PayloadType::ObjectId,
            PayloadType::Fixed,
            PayloadType::Fixed,
            PayloadType::ObjectId,
        ],
        &[],
        &[PayloadType::UInt, PayloadType::Fixed, PayloadType::Fixed],
        &[],
        &[PayloadType::ObjectId],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> WlDataDevice {
        WlDataDevice { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
