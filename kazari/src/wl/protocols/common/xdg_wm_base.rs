//! The xdg_wm_base interface is exposed as a global object enabling clients to turn
//! their wl_surfaces into windows in a desktop environment. it defines the basic
//! functionality needed for clients and the compositor to create windows that can
//! be dragged, resized, maximized, etc, as well as creating transient windows such
//! as popup menus.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// Destroy this xdg_wm_base object. destroying a bound xdg_wm_base object while
    /// there are surfaces still alive created by this xdg_wm_base object instance is
    /// illegal and will result in a protocol error.
    Destroy {},
    /// Create a positioner object. a positioner object is used to position surfaces
    /// relative to some parent surface. see the interface description and
    /// xdg_surface.get_popup for details.
    CreatePositioner {
        /// (no document).
        id: NewId,
    },
    /// This creates an xdg_surface for the given surface. while xdg_surface itself is
    /// not a role, the corresponding surface may only be assigned a role extending
    /// xdg_surface, such as xdg_toplevel or xdg_popup. this creates an xdg_surface for
    /// the given surface. an xdg_surface is used as basis to define a role to a given
    /// surface, such as xdg_toplevel or xdg_popup. it also manages functionality shared
    /// between xdg_surface based surface roles. see the documentation of xdg_surface
    /// for more details about what an xdg_surface is and how it is used.
    GetXdgSurface {
        /// (no document).
        id: NewId,
        /// (no document).
        surface: WlSurface,
    },
    /// A client must respond to a ping event with a pong request or the client may be
    /// deemed unresponsive. see xdg_wm_base.ping.
    Pong {
        /// Serial of the ping event.
        serial: u32,
    },
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::Destroy {} => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![],
            },
            Request::CreatePositioner { id } => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![id.into()],
            },
            Request::GetXdgSurface { id, surface } => RawMessage {
                sender,
                opcode: Opcode(3),
                args: smallvec![id.into(), surface.into()],
            },
            Request::Pong { serial } => RawMessage {
                sender,
                opcode: Opcode(4),
                args: smallvec![serial.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::Destroy {}),
            Opcode(2) => Ok(Request::CreatePositioner {
                id: from_payload!(NewId, m.args[0]),
            }),
            Opcode(3) => Ok(Request::GetXdgSurface {
                id: from_payload!(NewId, m.args[0]),

                surface: from_object_payload!(WlSurface, con.clone(), m.args[1]),
            }),
            Opcode(4) => Ok(Request::Pong {
                serial: from_payload!(UInt, m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::XdgWmBase(self)
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Error {
    /// Given wl_surface has another role.
    Role = 0,
    /// Xdg_wm_base was destroyed before children.
    DefunctSurfaces = 1,
    /// The client tried to map or destroy a non-topmost popup.
    NotTheTopmostPopup = 2,
    /// The client specified an invalid popup parent surface.
    InvalidPopupParent = 3,
    /// The client provided an invalid surface state.
    InvalidSurfaceState = 4,
    /// The client provided an invalid positioner.
    InvalidPositioner = 5,
}

impl Into<Payload> for Error {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Error {
    fn from(value: u32) -> Error {
        match value {
            0 => Error::Role,
            1 => Error::DefunctSurfaces,
            2 => Error::NotTheTopmostPopup,
            3 => Error::InvalidPopupParent,
            4 => Error::InvalidSurfaceState,
            5 => Error::InvalidPositioner,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {
    /// The ping event asks the client if it's still alive. pass the serial specified in
    /// the event back to the compositor by sending a "pong" request back with the
    /// specified serial. see xdg_wm_base.pong. compositors can use this to determine if
    /// the client is still alive. it's unspecified what will happen if the client
    /// doesn't respond to the ping request, or in what timeframe. clients should try to
    /// respond in a reasonable amount of time. a compositor is free to ping in any way
    /// it wants, but a client must always respond to any xdg_wm_base object it created.
    Ping {
        /// Pass this to the pong request.
        serial: u32,
    },
}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Event::Ping { serial } => RawMessage {
                sender,
                opcode: Opcode(5),
                args: smallvec![serial.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            Opcode(5) => Ok(Event::Ping {
                serial: from_payload!(UInt, m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::XdgWmBase(XdgWmBase::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Create desktop-style surfaces.
#[derive(Clone)]
pub struct XdgWmBase {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for XdgWmBase {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for XdgWmBase {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "XdgWmBase@{}", self.object_id.0)
    }
}

impl Into<Payload> for XdgWmBase {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for XdgWmBase {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "xdg_wm_base";
    const VERSION: u32 = 3;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[],
        &[PayloadType::NewId],
        &[PayloadType::NewId, PayloadType::ObjectId],
        &[PayloadType::UInt],
        &[PayloadType::UInt],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> XdgWmBase {
        XdgWmBase { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
