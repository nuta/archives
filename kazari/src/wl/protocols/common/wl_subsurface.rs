//! An additional interface to a wl_surface object, which has been made a sub-
//! surface. a sub-surface has one parent surface. a sub-surface's size and position
//! are not limited to that of the parent. particularly, a sub-surface is not
//! automatically clipped to its parent's area. a sub-surface becomes mapped, when a
//! non-null wl_buffer is applied and the parent surface is mapped. the order of
//! which one happens first is irrelevant. a sub-surface is hidden if the parent
//! becomes hidden, or if a null wl_buffer is applied. these rules apply recursively
//! through the tree of surfaces. the behaviour of a wl_surface.commit request on a
//! sub-surface depends on the sub-surface's mode. the possible modes are
//! synchronized and desynchronized, see methods wl_subsurface.set_sync and
//! wl_subsurface.set_desync. synchronized mode caches the wl_surface state to be
//! applied when the parent's state gets applied, and desynchronized mode applies
//! the pending wl_surface state directly. a sub-surface is initially in the
//! synchronized mode. sub-surfaces also have another kind of state, which is
//! managed by wl_subsurface requests, as opposed to wl_surface requests. this state
//! includes the sub-surface position relative to the parent surface
//! (wl_subsurface.set_position), and the stacking order of the parent and its sub-
//! surfaces (wl_subsurface.place_above and .place_below). this state is applied
//! when the parent surface's wl_surface state is applied, regardless of the sub-
//! surface's mode. as the exception, set_sync and set_desync are effective
//! immediately. the main surface can be thought to be always in desynchronized
//! mode, since it does not have a parent in the sub-surfaces sense. even if a sub-
//! surface is in desynchronized mode, it will behave as in synchronized mode, if
//! its parent surface behaves as in synchronized mode. this rule is applied
//! recursively throughout the tree of surfaces. this means, that one can set a sub-
//! surface into synchronized mode, and then assume that all its child and grand-
//! child sub-surfaces are synchronized, too, without explicitly setting them. if
//! the wl_surface associated with the wl_subsurface is destroyed, the wl_subsurface
//! object becomes inert. note, that destroying either object takes effect
//! immediately. if you need to synchronize the removal of a sub-surface to the
//! parent surface update, unmap the sub-surface first by attaching a null
//! wl_buffer, update parent, and then destroy the sub-surface. if the parent
//! wl_surface object is destroyed, the sub-surface is unmapped.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;

use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// The sub-surface interface is removed from the wl_surface object that was turned
    /// into a sub-surface with a wl_subcompositor.get_subsurface request. the
    /// wl_surface's association to the parent is deleted, and the wl_surface loses its
    /// role as a sub-surface. the wl_surface is unmapped immediately.
    Destroy {},
    /// This schedules a sub-surface position change. the sub-surface will be moved so
    /// that its origin (top left corner pixel) will be at the location x, y of the
    /// parent surface coordinate system. the coordinates are not restricted to the
    /// parent surface area. negative values are allowed. the scheduled coordinates will
    /// take effect whenever the state of the parent surface is applied. when this
    /// happens depends on whether the parent surface is in synchronized mode or not.
    /// see wl_subsurface.set_sync and wl_subsurface.set_desync for details. if more
    /// than one set_position request is invoked by the client before the commit of the
    /// parent surface, the position of a new request always replaces the scheduled
    /// position from any previous request. the initial position is 0, 0.
    SetPosition {
        /// X coordinate in the parent surface.
        x: i32,
        /// Y coordinate in the parent surface.
        y: i32,
    },
    /// This sub-surface is taken from the stack, and put back just above the reference
    /// surface, changing the z-order of the sub-surfaces. the reference surface must be
    /// one of the sibling surfaces, or the parent surface. using any other surface,
    /// including this sub-surface, will cause a protocol error. the z-order is double-
    /// buffered. requests are handled in order and applied immediately to a pending
    /// state. the final pending state is copied to the active state the next time the
    /// state of the parent surface is applied. when this happens depends on whether the
    /// parent surface is in synchronized mode or not. see wl_subsurface.set_sync and
    /// wl_subsurface.set_desync for details. a new sub-surface is initially added as
    /// the top-most in the stack of its siblings and parent.
    PlaceAbove {
        /// The reference surface.
        sibling: WlSurface,
    },
    /// The sub-surface is placed just below the reference surface. see
    /// wl_subsurface.place_above.
    PlaceBelow {
        /// The reference surface.
        sibling: WlSurface,
    },
    /// Change the commit behaviour of the sub-surface to synchronized mode, also
    /// described as the parent dependent mode. in synchronized mode, wl_surface.commit
    /// on a sub-surface will accumulate the committed state in a cache, but the state
    /// will not be applied and hence will not change the compositor output. the cached
    /// state is applied to the sub-surface immediately after the parent surface's state
    /// is applied. this ensures atomic updates of the parent and all its synchronized
    /// sub-surfaces. applying the cached state will invalidate the cache, so further
    /// parent surface commits do not (re-)apply old state. see wl_subsurface for the
    /// recursive effect of this mode.
    SetSync {},
    /// Change the commit behaviour of the sub-surface to desynchronized mode, also
    /// described as independent or freely running mode. in desynchronized mode,
    /// wl_surface.commit on a sub-surface will apply the pending state directly,
    /// without caching, as happens normally with a wl_surface. calling
    /// wl_surface.commit on the parent surface has no effect on the sub-surface's
    /// wl_surface state. this mode allows a sub-surface to be updated on its own. if
    /// cached state exists when wl_surface.commit is called in desynchronized mode, the
    /// pending state is added to the cached state, and applied as a whole. this
    /// invalidates the cache. note: even if a sub-surface is set to desynchronized, a
    /// parent sub-surface may override it to behave as synchronized. for details, see
    /// wl_subsurface. if a surface's parent surface behaves as desynchronized, then the
    /// cached state is applied on set_desync.
    SetDesync {},
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::Destroy {} => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![],
            },
            Request::SetPosition { x, y } => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![x.into(), y.into()],
            },
            Request::PlaceAbove { sibling } => RawMessage {
                sender,
                opcode: Opcode(3),
                args: smallvec![sibling.into()],
            },
            Request::PlaceBelow { sibling } => RawMessage {
                sender,
                opcode: Opcode(4),
                args: smallvec![sibling.into()],
            },
            Request::SetSync {} => RawMessage {
                sender,
                opcode: Opcode(5),
                args: smallvec![],
            },
            Request::SetDesync {} => RawMessage {
                sender,
                opcode: Opcode(6),
                args: smallvec![],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::Destroy {}),
            Opcode(2) => Ok(Request::SetPosition {
                x: from_payload!(Int, m.args[0]),

                y: from_payload!(Int, m.args[1]),
            }),
            Opcode(3) => Ok(Request::PlaceAbove {
                sibling: from_object_payload!(WlSurface, con.clone(), m.args[0]),
            }),
            Opcode(4) => Ok(Request::PlaceBelow {
                sibling: from_object_payload!(WlSurface, con.clone(), m.args[0]),
            }),
            Opcode(5) => Ok(Request::SetSync {}),
            Opcode(6) => Ok(Request::SetDesync {}),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::WlSubsurface(self)
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Error {
    /// Wl_surface is not a sibling or the parent.
    BadSurface = 0,
}

impl Into<Payload> for Error {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Error {
    fn from(value: u32) -> Error {
        match value {
            0 => Error::BadSurface,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {}
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::WlSubsurface(WlSubsurface::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Sub-surface interface to a wl_surface.
#[derive(Clone)]
pub struct WlSubsurface {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for WlSubsurface {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for WlSubsurface {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "WlSubsurface@{}", self.object_id.0)
    }
}

impl Into<Payload> for WlSubsurface {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for WlSubsurface {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "wl_subsurface";
    const VERSION: u32 = 1;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[],
        &[PayloadType::Int, PayloadType::Int],
        &[PayloadType::ObjectId],
        &[PayloadType::ObjectId],
        &[],
        &[],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> WlSubsurface {
        WlSubsurface { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
