//! The wl_pointer interface represents one or more input devices, such as mice,
//! which control the pointer location and pointer_focus of a seat. the wl_pointer
//! interface generates motion, enter and leave events for the surfaces that the
//! pointer is located over, and button and axis events for button presses, button
//! releases and scrolling.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;

use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// Set the pointer surface, i.e., the surface that contains the pointer image
    /// (cursor). this request gives the surface the role of a cursor. if the surface
    /// already has another role, it raises a protocol error. the cursor actually
    /// changes only if the pointer focus for this device is one of the requesting
    /// client's surfaces or the surface parameter is the current pointer surface. if
    /// there was a previous surface set with this request it is replaced. if surface is
    /// null, the pointer image is hidden. the parameters hotspot_x and hotspot_y define
    /// the position of the pointer surface relative to the pointer location. its top-
    /// left corner is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
    /// coordinates of the pointer location, in surface-local coordinates. on
    /// surface.attach requests to the pointer surface, hotspot_x and hotspot_y are
    /// decremented by the x and y parameters passed to the request. attach must be
    /// confirmed by wl_surface.commit as usual. the hotspot can also be updated by
    /// passing the currently set pointer surface to this request with new values for
    /// hotspot_x and hotspot_y. the current and pending input regions of the wl_surface
    /// are cleared, and wl_surface.set_input_region is ignored until the wl_surface is
    /// no longer used as the cursor. when the use as a cursor ends, the current and
    /// pending input regions become undefined, and the wl_surface is unmapped.
    SetCursor {
        /// Serial number of the enter event.
        serial: u32,
        /// Pointer surface.
        surface: Option<WlSurface>,
        /// Surface-local x coordinate.
        hotspot_x: i32,
        /// Surface-local y coordinate.
        hotspot_y: i32,
    },
    /// Using this request a client can tell the server that it is not going to use the
    /// pointer object anymore. this request destroys the pointer proxy object, so
    /// clients must not call wl_pointer_destroy() after using this request.
    Release {},
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::SetCursor {
                serial,
                surface,
                hotspot_x,
                hotspot_y,
            } => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![
                    serial.into(),
                    surface.into(),
                    hotspot_x.into(),
                    hotspot_y.into()
                ],
            },
            Request::Release {} => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::SetCursor {
                serial: from_payload!(UInt, m.args[0]),

                surface: from_optional_object_payload!(WlSurface, con.clone(), m.args[1]),

                hotspot_x: from_payload!(Int, m.args[2]),

                hotspot_y: from_payload!(Int, m.args[3]),
            }),
            Opcode(2) => Ok(Request::Release {}),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::WlPointer(self)
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Error {
    /// Given wl_surface has another role.
    Role = 0,
}

impl Into<Payload> for Error {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Error {
    fn from(value: u32) -> Error {
        match value {
            0 => Error::Role,

            _ => unreachable!(),
        }
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ButtonState {
    /// The button is not pressed.
    Released = 0,
    /// The button is pressed.
    Pressed = 1,
}

impl Into<Payload> for ButtonState {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for ButtonState {
    fn from(value: u32) -> ButtonState {
        match value {
            0 => ButtonState::Released,
            1 => ButtonState::Pressed,

            _ => unreachable!(),
        }
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Axis {
    /// Vertical axis.
    VerticalScroll = 0,
    /// Horizontal axis.
    HorizontalScroll = 1,
}

impl Into<Payload> for Axis {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Axis {
    fn from(value: u32) -> Axis {
        match value {
            0 => Axis::VerticalScroll,
            1 => Axis::HorizontalScroll,

            _ => unreachable!(),
        }
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AxisSource {
    /// A physical wheel rotation.
    Wheel = 0,
    /// Finger on a touch surface.
    Finger = 1,
    /// Continuous coordinate space.
    Continuous = 2,
    /// A physical wheel tilt.
    WheelTilt = 3,
}

impl Into<Payload> for AxisSource {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for AxisSource {
    fn from(value: u32) -> AxisSource {
        match value {
            0 => AxisSource::Wheel,
            1 => AxisSource::Finger,
            2 => AxisSource::Continuous,
            3 => AxisSource::WheelTilt,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {
    /// Notification that this seat's pointer is focused on a certain surface. when a
    /// seat's focus enters a surface, the pointer image is undefined and a client
    /// should respond to this event by setting an appropriate pointer image with the
    /// set_cursor request.
    Enter {
        /// Serial number of the enter event.
        serial: u32,
        /// Surface entered by the pointer.
        surface: WlSurface,
        /// Surface-local x coordinate.
        surface_x: f32,
        /// Surface-local y coordinate.
        surface_y: f32,
    },
    /// Notification that this seat's pointer is no longer focused on a certain surface.
    /// the leave notification is sent before the enter notification for the new focus.
    Leave {
        /// Serial number of the leave event.
        serial: u32,
        /// Surface left by the pointer.
        surface: WlSurface,
    },
    /// Notification of pointer location change. the arguments surface_x and surface_y
    /// are the location relative to the focused surface.
    Motion {
        /// Timestamp with millisecond granularity.
        time: u32,
        /// Surface-local x coordinate.
        surface_x: f32,
        /// Surface-local y coordinate.
        surface_y: f32,
    },
    /// Mouse button click and release notifications. the location of the click is given
    /// by the last motion or enter event. the time argument is a timestamp with
    /// millisecond granularity, with an undefined base. the button is a button code as
    /// defined in the linux kernel's linux/input-event-codes.h header file, e.g.
    /// btn_left. any 16-bit button code value is reserved for future additions to the
    /// kernel's event code list. all other button codes above 0xffff are currently
    /// undefined but may be used in future versions of this protocol.
    Button {
        /// Serial number of the button event.
        serial: u32,
        /// Timestamp with millisecond granularity.
        time: u32,
        /// Button that produced the event.
        button: u32,
        /// Physical state of the button.
        state: ButtonState,
    },
    /// Scroll and other axis notifications. for scroll events (vertical and horizontal
    /// scroll axes), the value parameter is the length of a vector along the specified
    /// axis in a coordinate space identical to those of motion events, representing a
    /// relative movement along the specified axis. for devices that support movements
    /// non-parallel to axes multiple axis events will be emitted. when applicable, for
    /// example for touch pads, the server can choose to emit scroll events where the
    /// motion vector is equivalent to a motion event vector. when applicable, a client
    /// can transform its content relative to the scroll distance.
    Axis {
        /// Timestamp with millisecond granularity.
        time: u32,
        /// Axis type.
        axis: Axis,
        /// Length of vector in surface-local coordinate space.
        value: f32,
    },
    /// Indicates the end of a set of events that logically belong together. a client is
    /// expected to accumulate the data in all events within the frame before
    /// proceeding. all wl_pointer events before a wl_pointer.frame event belong
    /// logically together. for example, in a diagonal scroll motion the compositor will
    /// send an optional wl_pointer.axis_source event, two wl_pointer.axis events
    /// (horizontal and vertical) and finally a wl_pointer.frame event. the client may
    /// use this information to calculate a diagonal vector for scrolling. when multiple
    /// wl_pointer.axis events occur within the same frame, the motion vector is the
    /// combined motion of all events. when a wl_pointer.axis and a wl_pointer.axis_stop
    /// event occur within the same frame, this indicates that axis movement in one axis
    /// has stopped but continues in the other axis. when multiple wl_pointer.axis_stop
    /// events occur within the same frame, this indicates that these axes stopped in
    /// the same instance. a wl_pointer.frame event is sent for every logical event
    /// group, even if the group only contains a single wl_pointer event. specifically,
    /// a client may get a sequence: motion, frame, button, frame, axis, frame,
    /// axis_stop, frame. the wl_pointer.enter and wl_pointer.leave events are logical
    /// events generated by the compositor and not the hardware. these events are also
    /// grouped by a wl_pointer.frame. when a pointer moves from one surface to another,
    /// a compositor should group the wl_pointer.leave event within the same
    /// wl_pointer.frame. however, a client must not rely on wl_pointer.leave and
    /// wl_pointer.enter being in the same wl_pointer.frame. compositor-specific
    /// policies may require the wl_pointer.leave and wl_pointer.enter event being split
    /// across multiple wl_pointer.frame groups.
    Frame {},
    /// Source information for scroll and other axes. this event does not occur on its
    /// own. it is sent before a wl_pointer.frame event and carries the source
    /// information for all events within that frame. the source specifies how this
    /// event was generated. if the source is wl_pointer.axis_source.finger, a
    /// wl_pointer.axis_stop event will be sent when the user lifts the finger off the
    /// device. if the source is wl_pointer.axis_source.wheel,
    /// wl_pointer.axis_source.wheel_tilt or wl_pointer.axis_source.continuous, a
    /// wl_pointer.axis_stop event may or may not be sent. whether a compositor sends an
    /// axis_stop event for these sources is hardware-specific and implementation-
    /// dependent; clients must not rely on receiving an axis_stop event for these
    /// scroll sources and should treat scroll sequences from these scroll sources as
    /// unterminated by default. this event is optional. if the source is unknown for a
    /// particular axis event sequence, no event is sent. only one
    /// wl_pointer.axis_source event is permitted per frame. the order of
    /// wl_pointer.axis_discrete and wl_pointer.axis_source is not guaranteed.
    AxisSource {
        /// Source of the axis event.
        axis_source: AxisSource,
    },
    /// Stop notification for scroll and other axes. for some wl_pointer.axis_source
    /// types, a wl_pointer.axis_stop event is sent to notify a client that the axis
    /// sequence has terminated. this enables the client to implement kinetic scrolling.
    /// see the wl_pointer.axis_source documentation for information on when this event
    /// may be generated. any wl_pointer.axis events with the same axis_source after
    /// this event should be considered as the start of a new axis motion. the timestamp
    /// is to be interpreted identical to the timestamp in the wl_pointer.axis event.
    /// the timestamp value may be the same as a preceding wl_pointer.axis event.
    AxisStop {
        /// Timestamp with millisecond granularity.
        time: u32,
        /// The axis stopped with this event.
        axis: Axis,
    },
    /// Discrete step information for scroll and other axes. this event carries the axis
    /// value of the wl_pointer.axis event in discrete steps (e.g. mouse wheel clicks).
    /// this event does not occur on its own, it is coupled with a wl_pointer.axis event
    /// that represents this axis value on a continuous scale. the protocol guarantees
    /// that each axis_discrete event is always followed by exactly one axis event with
    /// the same axis number within the same wl_pointer.frame. note that the protocol
    /// allows for other events to occur between the axis_discrete and its coupled axis
    /// event, including other axis_discrete or axis events. this event is optional;
    /// continuous scrolling devices like two-finger scrolling on touchpads do not have
    /// discrete steps and do not generate this event. the discrete value carries the
    /// directional information. e.g. a value of -2 is two steps towards the negative
    /// direction of this axis. the axis number is identical to the axis number in the
    /// associated axis event. the order of wl_pointer.axis_discrete and
    /// wl_pointer.axis_source is not guaranteed.
    AxisDiscrete {
        /// Axis type.
        axis: Axis,
        /// Number of steps.
        discrete: i32,
    },
}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Event::Enter {
                serial,
                surface,
                surface_x,
                surface_y,
            } => RawMessage {
                sender,
                opcode: Opcode(3),
                args: smallvec![
                    serial.into(),
                    surface.into(),
                    surface_x.into(),
                    surface_y.into()
                ],
            },
            Event::Leave { serial, surface } => RawMessage {
                sender,
                opcode: Opcode(4),
                args: smallvec![serial.into(), surface.into()],
            },
            Event::Motion {
                time,
                surface_x,
                surface_y,
            } => RawMessage {
                sender,
                opcode: Opcode(5),
                args: smallvec![time.into(), surface_x.into(), surface_y.into()],
            },
            Event::Button {
                serial,
                time,
                button,
                state,
            } => RawMessage {
                sender,
                opcode: Opcode(6),
                args: smallvec![serial.into(), time.into(), button.into(), state.into()],
            },
            Event::Axis { time, axis, value } => RawMessage {
                sender,
                opcode: Opcode(7),
                args: smallvec![time.into(), axis.into(), value.into()],
            },
            Event::Frame {} => RawMessage {
                sender,
                opcode: Opcode(8),
                args: smallvec![],
            },
            Event::AxisSource { axis_source } => RawMessage {
                sender,
                opcode: Opcode(9),
                args: smallvec![axis_source.into()],
            },
            Event::AxisStop { time, axis } => RawMessage {
                sender,
                opcode: Opcode(10),
                args: smallvec![time.into(), axis.into()],
            },
            Event::AxisDiscrete { axis, discrete } => RawMessage {
                sender,
                opcode: Opcode(11),
                args: smallvec![axis.into(), discrete.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            Opcode(3) => Ok(Event::Enter {
                serial: from_payload!(UInt, m.args[0]),

                surface: from_object_payload!(WlSurface, con.clone(), m.args[1]),

                surface_x: from_payload!(Fixed, m.args[2]),

                surface_y: from_payload!(Fixed, m.args[3]),
            }),
            Opcode(4) => Ok(Event::Leave {
                serial: from_payload!(UInt, m.args[0]),

                surface: from_object_payload!(WlSurface, con.clone(), m.args[1]),
            }),
            Opcode(5) => Ok(Event::Motion {
                time: from_payload!(UInt, m.args[0]),

                surface_x: from_payload!(Fixed, m.args[1]),

                surface_y: from_payload!(Fixed, m.args[2]),
            }),
            Opcode(6) => Ok(Event::Button {
                serial: from_payload!(UInt, m.args[0]),

                time: from_payload!(UInt, m.args[1]),

                button: from_payload!(UInt, m.args[2]),

                state: from_payload!(UInt, m.args[3]),
            }),
            Opcode(7) => Ok(Event::Axis {
                time: from_payload!(UInt, m.args[0]),

                axis: from_payload!(UInt, m.args[1]),

                value: from_payload!(Fixed, m.args[2]),
            }),
            Opcode(8) => Ok(Event::Frame {}),
            Opcode(9) => Ok(Event::AxisSource {
                axis_source: from_payload!(UInt, m.args[0]),
            }),
            Opcode(10) => Ok(Event::AxisStop {
                time: from_payload!(UInt, m.args[0]),

                axis: from_payload!(UInt, m.args[1]),
            }),
            Opcode(11) => Ok(Event::AxisDiscrete {
                axis: from_payload!(UInt, m.args[0]),

                discrete: from_payload!(Int, m.args[1]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::WlPointer(WlPointer::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Pointer input device.
#[derive(Clone)]
pub struct WlPointer {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for WlPointer {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for WlPointer {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "WlPointer@{}", self.object_id.0)
    }
}

impl Into<Payload> for WlPointer {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for WlPointer {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "wl_pointer";
    const VERSION: u32 = 7;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[
            PayloadType::UInt,
            PayloadType::ObjectId,
            PayloadType::Int,
            PayloadType::Int,
        ],
        &[],
        &[
            PayloadType::UInt,
            PayloadType::ObjectId,
            PayloadType::Fixed,
            PayloadType::Fixed,
        ],
        &[PayloadType::UInt, PayloadType::ObjectId],
        &[PayloadType::UInt, PayloadType::Fixed, PayloadType::Fixed],
        &[
            PayloadType::UInt,
            PayloadType::UInt,
            PayloadType::UInt,
            PayloadType::UInt,
        ],
        &[PayloadType::UInt, PayloadType::UInt, PayloadType::Fixed],
        &[],
        &[PayloadType::UInt],
        &[PayloadType::UInt, PayloadType::UInt],
        &[PayloadType::UInt, PayloadType::Int],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> WlPointer {
        WlPointer { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
