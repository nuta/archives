//! An output describes part of the compositor geometry. the compositor works in the
//! 'compositor coordinate system' and an output corresponds to a rectangular area
//! in that space that is actually visible. this typically corresponds to a monitor
//! that displays part of the compositor space. this object is published as global
//! during start up, or when a monitor is hotplugged.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;

use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// Using this request a client can tell the server that it is not going to use the
    /// output object anymore.
    Release {},
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::Release {} => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::Release {}),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::WlOutput(self)
    }
}

#[repr(i32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Subpixel {
    /// Unknown geometry.
    Unknown = 0,
    /// No geometry.
    None = 1,
    /// Horizontal rgb.
    HorizontalRgb = 2,
    /// Horizontal bgr.
    HorizontalBgr = 3,
    /// Vertical rgb.
    VerticalRgb = 4,
    /// Vertical bgr.
    VerticalBgr = 5,
}

impl Into<Payload> for Subpixel {
    fn into(self) -> Payload {
        Payload::Int(self as i32)
    }
}

impl From<i32> for Subpixel {
    fn from(value: i32) -> Subpixel {
        match value {
            0 => Subpixel::Unknown,
            1 => Subpixel::None,
            2 => Subpixel::HorizontalRgb,
            3 => Subpixel::HorizontalBgr,
            4 => Subpixel::VerticalRgb,
            5 => Subpixel::VerticalBgr,

            _ => unreachable!(),
        }
    }
}

#[repr(i32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Transform {
    /// No transform.
    Normal = 0,
    /// 90 degrees counter-clockwise.
    _90 = 1,
    /// 180 degrees counter-clockwise.
    _180 = 2,
    /// 270 degrees counter-clockwise.
    _270 = 3,
    /// 180 degree flip around a vertical axis.
    Flipped = 4,
    /// Flip and rotate 90 degrees counter-clockwise.
    Flipped90 = 5,
    /// Flip and rotate 180 degrees counter-clockwise.
    Flipped180 = 6,
    /// Flip and rotate 270 degrees counter-clockwise.
    Flipped270 = 7,
}

impl Into<Payload> for Transform {
    fn into(self) -> Payload {
        Payload::Int(self as i32)
    }
}

impl From<i32> for Transform {
    fn from(value: i32) -> Transform {
        match value {
            0 => Transform::Normal,
            1 => Transform::_90,
            2 => Transform::_180,
            3 => Transform::_270,
            4 => Transform::Flipped,
            5 => Transform::Flipped90,
            6 => Transform::Flipped180,
            7 => Transform::Flipped270,

            _ => unreachable!(),
        }
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Mode {
    /// Indicates this is the current mode.
    Current = 0x1,
    /// Indicates this is the preferred mode.
    Preferred = 0x2,
}

impl Into<Payload> for Mode {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Mode {
    fn from(value: u32) -> Mode {
        match value {
            0x1 => Mode::Current,
            0x2 => Mode::Preferred,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {
    /// The geometry event describes geometric properties of the output. the event is
    /// sent when binding to the output object and whenever any of the properties
    /// change. the physical size can be set to zero if it doesn't make sense for this
    /// output (e.g. for projectors or virtual outputs). note: wl_output only advertises
    /// partial information about the output position and identification. some
    /// compositors, for instance those not implementing a desktop-style output layout
    /// or those exposing virtual outputs, might fake this information. instead of using
    /// x and y, clients should use xdg_output.logical_position. instead of using make
    /// and model, clients should use xdg_output.name and xdg_output.description.
    Geometry {
        /// X position within the global compositor space.
        x: i32,
        /// Y position within the global compositor space.
        y: i32,
        /// Width in millimeters of the output.
        physical_width: i32,
        /// Height in millimeters of the output.
        physical_height: i32,
        /// Subpixel orientation of the output.
        subpixel: Subpixel,
        /// Textual description of the manufacturer.
        make: String,
        /// Textual description of the model.
        model: String,
        /// Transform that maps framebuffer to output.
        transform: Transform,
    },
    /// The mode event describes an available mode for the output. the event is sent
    /// when binding to the output object and there will always be one mode, the current
    /// mode. the event is sent again if an output changes mode, for the mode that is
    /// now current. in other words, the current mode is always the last mode that was
    /// received with the current flag set. non-current modes are deprecated. a
    /// compositor can decide to only advertise the current mode and never send other
    /// modes. clients should not rely on non-current modes. the size of a mode is given
    /// in physical hardware units of the output device. this is not necessarily the
    /// same as the output size in the global compositor space. for instance, the output
    /// may be scaled, as described in wl_output.scale, or transformed, as described in
    /// wl_output.transform. clients willing to retrieve the output size in the global
    /// compositor space should use xdg_output.logical_size instead. the vertical
    /// refresh rate can be set to zero if it doesn't make sense for this output (e.g.
    /// for virtual outputs). clients should not use the refresh rate to schedule
    /// frames. instead, they should use the wl_surface.frame event or the presentation-
    /// time protocol. note: this information is not always meaningful for all outputs.
    /// some compositors, such as those exposing virtual outputs, might fake the refresh
    /// rate or the size.
    Mode {
        /// Bitfield of mode flags.
        flags: Mode,
        /// Width of the mode in hardware units.
        width: i32,
        /// Height of the mode in hardware units.
        height: i32,
        /// Vertical refresh rate in mhz.
        refresh: i32,
    },
    /// This event is sent after all other properties have been sent after binding to
    /// the output object and after any other property changes done after that. this
    /// allows changes to the output properties to be seen as atomic, even if they
    /// happen via multiple events.
    Done {},
    /// This event contains scaling geometry information that is not in the geometry
    /// event. it may be sent after binding the output object or if the output scale
    /// changes later. if it is not sent, the client should assume a scale of 1. a scale
    /// larger than 1 means that the compositor will automatically scale surface buffers
    /// by this amount when rendering. this is used for very high resolution displays
    /// where applications rendering at the native resolution would be too small to be
    /// legible. it is intended that scaling aware clients track the current output of a
    /// surface, and if it is on a scaled output it should use
    /// wl_surface.set_buffer_scale with the scale of the output. that way the
    /// compositor can avoid scaling the surface, and the client can supply a higher
    /// detail image.
    Scale {
        /// Scaling factor of output.
        factor: i32,
    },
}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Event::Geometry {
                x,
                y,
                physical_width,
                physical_height,
                subpixel,
                make,
                model,
                transform,
            } => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![
                    x.into(),
                    y.into(),
                    physical_width.into(),
                    physical_height.into(),
                    subpixel.into(),
                    make.into(),
                    model.into(),
                    transform.into()
                ],
            },
            Event::Mode {
                flags,
                width,
                height,
                refresh,
            } => RawMessage {
                sender,
                opcode: Opcode(3),
                args: smallvec![flags.into(), width.into(), height.into(), refresh.into()],
            },
            Event::Done {} => RawMessage {
                sender,
                opcode: Opcode(4),
                args: smallvec![],
            },
            Event::Scale { factor } => RawMessage {
                sender,
                opcode: Opcode(5),
                args: smallvec![factor.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            Opcode(2) => Ok(Event::Geometry {
                x: from_payload!(Int, m.args[0]),

                y: from_payload!(Int, m.args[1]),

                physical_width: from_payload!(Int, m.args[2]),

                physical_height: from_payload!(Int, m.args[3]),

                subpixel: from_payload!(Int, m.args[4]),

                make: from_payload!(String, m.args[5]),

                model: from_payload!(String, m.args[6]),

                transform: from_payload!(Int, m.args[7]),
            }),
            Opcode(3) => Ok(Event::Mode {
                flags: from_payload!(UInt, m.args[0]),

                width: from_payload!(Int, m.args[1]),

                height: from_payload!(Int, m.args[2]),

                refresh: from_payload!(Int, m.args[3]),
            }),
            Opcode(4) => Ok(Event::Done {}),
            Opcode(5) => Ok(Event::Scale {
                factor: from_payload!(Int, m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::WlOutput(WlOutput::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Compositor output region.
#[derive(Clone)]
pub struct WlOutput {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for WlOutput {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for WlOutput {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "WlOutput@{}", self.object_id.0)
    }
}

impl Into<Payload> for WlOutput {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for WlOutput {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "wl_output";
    const VERSION: u32 = 3;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[],
        &[
            PayloadType::Int,
            PayloadType::Int,
            PayloadType::Int,
            PayloadType::Int,
            PayloadType::Int,
            PayloadType::String,
            PayloadType::String,
            PayloadType::Int,
        ],
        &[
            PayloadType::UInt,
            PayloadType::Int,
            PayloadType::Int,
            PayloadType::Int,
        ],
        &[],
        &[PayloadType::Int],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> WlOutput {
        WlOutput { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
