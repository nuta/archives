//! An interface that may be implemented by a wl_surface, for implementations that
//! provide a desktop-style user interface. it provides requests to treat surfaces
//! like toplevel, fullscreen or popup windows, move, resize or maximize them,
//! associate metadata like title and class, etc. on the server side the object is
//! automatically destroyed when the related wl_surface is destroyed. on the client
//! side, wl_shell_surface_destroy() must be called before destroying the wl_surface
//! object.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;

use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// A client must respond to a ping event with a pong request or the client may be
    /// deemed unresponsive.
    Pong {
        /// Serial number of the ping event.
        serial: u32,
    },
    /// Start a pointer-driven move of the surface. this request must be used in
    /// response to a button press event. the server may ignore move requests depending
    /// on the state of the surface (e.g. fullscreen or maximized).
    Move {
        /// Seat whose pointer is used.
        seat: WlSeat,
        /// Serial number of the implicit grab on the pointer.
        serial: u32,
    },
    /// Start a pointer-driven resizing of the surface. this request must be used in
    /// response to a button press event. the server may ignore resize requests
    /// depending on the state of the surface (e.g. fullscreen or maximized).
    Resize {
        /// Seat whose pointer is used.
        seat: WlSeat,
        /// Serial number of the implicit grab on the pointer.
        serial: u32,
        /// Which edge or corner is being dragged.
        edges: Resize,
    },
    /// Map the surface as a toplevel surface. a toplevel surface is not fullscreen,
    /// maximized or transient.
    SetToplevel {},
    /// Map the surface relative to an existing surface. the x and y arguments specify
    /// the location of the upper left corner of the surface relative to the upper left
    /// corner of the parent surface, in surface-local coordinates. the flags argument
    /// controls details of the transient behaviour.
    SetTransient {
        /// Parent surface.
        parent: WlSurface,
        /// Surface-local x coordinate.
        x: i32,
        /// Surface-local y coordinate.
        y: i32,
        /// Transient surface behavior.
        flags: Transient,
    },
    /// Map the surface as a fullscreen surface. if an output parameter is given then
    /// the surface will be made fullscreen on that output. if the client does not
    /// specify the output then the compositor will apply its policy - usually choosing
    /// the output on which the surface has the biggest surface area. the client may
    /// specify a method to resolve a size conflict between the output size and the
    /// surface size - this is provided through the method parameter. the framerate
    /// parameter is used only when the method is set to "driver", to indicate the
    /// preferred framerate. a value of 0 indicates that the client does not care about
    /// framerate. the framerate is specified in mhz, that is framerate of 60000 is
    /// 60hz. a method of "scale" or "driver" implies a scaling operation of the
    /// surface, either via a direct scaling operation or a change of the output mode.
    /// this will override any kind of output scaling, so that mapping a surface with a
    /// buffer size equal to the mode can fill the screen independent of buffer_scale. a
    /// method of "fill" means we don't scale up the buffer, however any output scale is
    /// applied. this means that you may run into an edge case where the application
    /// maps a buffer with the same size of the output mode but buffer_scale 1 (thus
    /// making a surface larger than the output). in this case it is allowed to
    /// downscale the results to fit the screen. the compositor must reply to this
    /// request with a configure event with the dimensions for the output on which the
    /// surface will be made fullscreen.
    SetFullscreen {
        /// Method for resolving size conflict.
        method: FullscreenMethod,
        /// Framerate in mhz.
        framerate: u32,
        /// Output on which the surface is to be fullscreen.
        output: Option<WlOutput>,
    },
    /// Map the surface as a popup. a popup surface is a transient surface with an added
    /// pointer grab. an existing implicit grab will be changed to owner-events mode,
    /// and the popup grab will continue after the implicit grab ends (i.e. releasing
    /// the mouse button does not cause the popup to be unmapped). the popup grab
    /// continues until the window is destroyed or a mouse button is pressed in any
    /// other client's window. a click in any of the client's surfaces is reported as
    /// normal, however, clicks in other clients' surfaces will be discarded and trigger
    /// the callback. the x and y arguments specify the location of the upper left
    /// corner of the surface relative to the upper left corner of the parent surface,
    /// in surface-local coordinates.
    SetPopup {
        /// Seat whose pointer is used.
        seat: WlSeat,
        /// Serial number of the implicit grab on the pointer.
        serial: u32,
        /// Parent surface.
        parent: WlSurface,
        /// Surface-local x coordinate.
        x: i32,
        /// Surface-local y coordinate.
        y: i32,
        /// Transient surface behavior.
        flags: Transient,
    },
    /// Map the surface as a maximized surface. if an output parameter is given then the
    /// surface will be maximized on that output. if the client does not specify the
    /// output then the compositor will apply its policy - usually choosing the output
    /// on which the surface has the biggest surface area. the compositor will reply
    /// with a configure event telling the expected new surface size. the operation is
    /// completed on the next buffer attach to this surface. a maximized surface
    /// typically fills the entire output it is bound to, except for desktop elements
    /// such as panels. this is the main difference between a maximized shell surface
    /// and a fullscreen shell surface. the details depend on the compositor
    /// implementation.
    SetMaximized {
        /// Output on which the surface is to be maximized.
        output: Option<WlOutput>,
    },
    /// Set a short title for the surface. this string may be used to identify the
    /// surface in a task bar, window list, or other user interface elements provided by
    /// the compositor. the string must be encoded in utf-8.
    SetTitle {
        /// Surface title.
        title: String,
    },
    /// Set a class for the surface. the surface class identifies the general class of
    /// applications to which the surface belongs. a common convention is to use the
    /// file name (or the full path if it is a non-standard location) of the
    /// application's .desktop file as the class.
    SetClass {
        /// Surface class.
        class_: String,
    },
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::Pong { serial } => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![serial.into()],
            },
            Request::Move { seat, serial } => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![seat.into(), serial.into()],
            },
            Request::Resize {
                seat,
                serial,
                edges,
            } => RawMessage {
                sender,
                opcode: Opcode(3),
                args: smallvec![seat.into(), serial.into(), edges.into()],
            },
            Request::SetToplevel {} => RawMessage {
                sender,
                opcode: Opcode(4),
                args: smallvec![],
            },
            Request::SetTransient {
                parent,
                x,
                y,
                flags,
            } => RawMessage {
                sender,
                opcode: Opcode(5),
                args: smallvec![parent.into(), x.into(), y.into(), flags.into()],
            },
            Request::SetFullscreen {
                method,
                framerate,
                output,
            } => RawMessage {
                sender,
                opcode: Opcode(6),
                args: smallvec![method.into(), framerate.into(), output.into()],
            },
            Request::SetPopup {
                seat,
                serial,
                parent,
                x,
                y,
                flags,
            } => RawMessage {
                sender,
                opcode: Opcode(7),
                args: smallvec![
                    seat.into(),
                    serial.into(),
                    parent.into(),
                    x.into(),
                    y.into(),
                    flags.into()
                ],
            },
            Request::SetMaximized { output } => RawMessage {
                sender,
                opcode: Opcode(8),
                args: smallvec![output.into()],
            },
            Request::SetTitle { title } => RawMessage {
                sender,
                opcode: Opcode(9),
                args: smallvec![title.into()],
            },
            Request::SetClass { class_ } => RawMessage {
                sender,
                opcode: Opcode(10),
                args: smallvec![class_.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::Pong {
                serial: from_payload!(UInt, m.args[0]),
            }),
            Opcode(2) => Ok(Request::Move {
                seat: from_object_payload!(WlSeat, con.clone(), m.args[0]),

                serial: from_payload!(UInt, m.args[1]),
            }),
            Opcode(3) => Ok(Request::Resize {
                seat: from_object_payload!(WlSeat, con.clone(), m.args[0]),

                serial: from_payload!(UInt, m.args[1]),

                edges: from_payload!(UInt, m.args[2]),
            }),
            Opcode(4) => Ok(Request::SetToplevel {}),
            Opcode(5) => Ok(Request::SetTransient {
                parent: from_object_payload!(WlSurface, con.clone(), m.args[0]),

                x: from_payload!(Int, m.args[1]),

                y: from_payload!(Int, m.args[2]),

                flags: from_payload!(UInt, m.args[3]),
            }),
            Opcode(6) => Ok(Request::SetFullscreen {
                method: from_payload!(UInt, m.args[0]),

                framerate: from_payload!(UInt, m.args[1]),

                output: from_optional_object_payload!(WlOutput, con.clone(), m.args[2]),
            }),
            Opcode(7) => Ok(Request::SetPopup {
                seat: from_object_payload!(WlSeat, con.clone(), m.args[0]),

                serial: from_payload!(UInt, m.args[1]),

                parent: from_object_payload!(WlSurface, con.clone(), m.args[2]),

                x: from_payload!(Int, m.args[3]),

                y: from_payload!(Int, m.args[4]),

                flags: from_payload!(UInt, m.args[5]),
            }),
            Opcode(8) => Ok(Request::SetMaximized {
                output: from_optional_object_payload!(WlOutput, con.clone(), m.args[0]),
            }),
            Opcode(9) => Ok(Request::SetTitle {
                title: from_payload!(String, m.args[0]),
            }),
            Opcode(10) => Ok(Request::SetClass {
                class_: from_payload!(String, m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::WlShellSurface(self)
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Resize {
    /// No edge.
    None = 0,
    /// Top edge.
    Top = 1,
    /// Bottom edge.
    Bottom = 2,
    /// Left edge.
    Left = 4,
    /// Top and left edges.
    TopLeft = 5,
    /// Bottom and left edges.
    BottomLeft = 6,
    /// Right edge.
    Right = 8,
    /// Top and right edges.
    TopRight = 9,
    /// Bottom and right edges.
    BottomRight = 10,
}

impl Into<Payload> for Resize {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Resize {
    fn from(value: u32) -> Resize {
        match value {
            0 => Resize::None,
            1 => Resize::Top,
            2 => Resize::Bottom,
            4 => Resize::Left,
            5 => Resize::TopLeft,
            6 => Resize::BottomLeft,
            8 => Resize::Right,
            9 => Resize::TopRight,
            10 => Resize::BottomRight,

            _ => unreachable!(),
        }
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Transient {
    /// Do not set keyboard focus.
    Inactive = 0x1,
}

impl Into<Payload> for Transient {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Transient {
    fn from(value: u32) -> Transient {
        match value {
            0x1 => Transient::Inactive,

            _ => unreachable!(),
        }
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum FullscreenMethod {
    /// No preference, apply default policy.
    Default = 0,
    /// Scale, preserve the surface's aspect ratio and center on output.
    Scale = 1,
    /// Switch output mode to the smallest mode that can fit the surface, add black
    /// borders to compensate size mismatch.
    Driver = 2,
    /// No upscaling, center on output and add black borders to compensate size
    /// mismatch.
    Fill = 3,
}

impl Into<Payload> for FullscreenMethod {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for FullscreenMethod {
    fn from(value: u32) -> FullscreenMethod {
        match value {
            0 => FullscreenMethod::Default,
            1 => FullscreenMethod::Scale,
            2 => FullscreenMethod::Driver,
            3 => FullscreenMethod::Fill,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {
    /// Ping a client to check if it is receiving events and sending requests. a client
    /// is expected to reply with a pong request.
    Ping {
        /// Serial number of the ping.
        serial: u32,
    },
    /// The configure event asks the client to resize its surface. the size is a hint,
    /// in the sense that the client is free to ignore it if it doesn't resize, pick a
    /// smaller size (to satisfy aspect ratio or resize in steps of nxm pixels). the
    /// edges parameter provides a hint about how the surface was resized. the client
    /// may use this information to decide how to adjust its content to the new size
    /// (e.g. a scrolling area might adjust its content position to leave the viewable
    /// content unmoved). the client is free to dismiss all but the last configure event
    /// it received. the width and height arguments specify the size of the window in
    /// surface-local coordinates.
    Configure {
        /// How the surface was resized.
        edges: Resize,
        /// New width of the surface.
        width: i32,
        /// New height of the surface.
        height: i32,
    },
    /// The popup_done event is sent out when a popup grab is broken, that is, when the
    /// user clicks a surface that doesn't belong to the client owning the popup
    /// surface.
    PopupDone {},
}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Event::Ping { serial } => RawMessage {
                sender,
                opcode: Opcode(11),
                args: smallvec![serial.into()],
            },
            Event::Configure {
                edges,
                width,
                height,
            } => RawMessage {
                sender,
                opcode: Opcode(12),
                args: smallvec![edges.into(), width.into(), height.into()],
            },
            Event::PopupDone {} => RawMessage {
                sender,
                opcode: Opcode(13),
                args: smallvec![],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            Opcode(11) => Ok(Event::Ping {
                serial: from_payload!(UInt, m.args[0]),
            }),
            Opcode(12) => Ok(Event::Configure {
                edges: from_payload!(UInt, m.args[0]),

                width: from_payload!(Int, m.args[1]),

                height: from_payload!(Int, m.args[2]),
            }),
            Opcode(13) => Ok(Event::PopupDone {}),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::WlShellSurface(WlShellSurface::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Desktop-style metadata interface.
#[derive(Clone)]
pub struct WlShellSurface {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for WlShellSurface {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for WlShellSurface {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "WlShellSurface@{}", self.object_id.0)
    }
}

impl Into<Payload> for WlShellSurface {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for WlShellSurface {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "wl_shell_surface";
    const VERSION: u32 = 1;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[PayloadType::UInt],
        &[PayloadType::ObjectId, PayloadType::UInt],
        &[PayloadType::ObjectId, PayloadType::UInt, PayloadType::UInt],
        &[],
        &[
            PayloadType::ObjectId,
            PayloadType::Int,
            PayloadType::Int,
            PayloadType::UInt,
        ],
        &[PayloadType::UInt, PayloadType::UInt, PayloadType::ObjectId],
        &[
            PayloadType::ObjectId,
            PayloadType::UInt,
            PayloadType::ObjectId,
            PayloadType::Int,
            PayloadType::Int,
            PayloadType::UInt,
        ],
        &[PayloadType::ObjectId],
        &[PayloadType::String],
        &[PayloadType::String],
        &[PayloadType::UInt],
        &[PayloadType::UInt, PayloadType::Int, PayloadType::Int],
        &[],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> WlShellSurface {
        WlShellSurface { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
