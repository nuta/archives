//! An interface that may be implemented by a wl_surface, for implementations that
//! provide a desktop-style user interface. it provides a base set of functionality
//! required to construct user interface elements requiring management by the
//! compositor, such as toplevel windows, menus, etc. the types of functionality are
//! split into xdg_surface roles. creating an xdg_surface does not set the role for
//! a wl_surface. in order to map an xdg_surface, the client must create a role-
//! specific object using, e.g., get_toplevel, get_popup. the wl_surface for any
//! given xdg_surface can have at most one role, and may not be assigned any role
//! not based on xdg_surface. a role must be assigned before any other requests are
//! made to the xdg_surface object. the client must call wl_surface.commit on the
//! corresponding wl_surface for the xdg_surface state to take effect. creating an
//! xdg_surface from a wl_surface which has a buffer attached or committed is a
//! client error, and any attempts by a client to attach or manipulate a buffer
//! prior to the first xdg_surface.configure call must also be treated as errors.
//! after creating a role-specific object and setting it up, the client must perform
//! an initial commit without any buffer attached. the compositor will reply with an
//! xdg_surface.configure event. the client must acknowledge it and is then allowed
//! to attach a buffer to map the surface. mapping an xdg_surface-based role surface
//! is defined as making it possible for the surface to be shown by the compositor.
//! note that a mapped surface is not guaranteed to be visible once it is mapped.
//! for an xdg_surface to be mapped by the compositor, the following conditions must
//! be met: (1) the client has assigned an xdg_surface-based role to the surface (2)
//! the client has set and committed the xdg_surface state and the role-dependent
//! state to the surface (3) the client has committed a buffer to the surface a
//! newly-unmapped surface is considered to have met condition (1) out of the 3
//! required conditions for mapping a surface if its role surface has not been
//! destroyed.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;

use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// Destroy the xdg_surface object. an xdg_surface must only be destroyed after its
    /// role object has been destroyed.
    Destroy {},
    /// This creates an xdg_toplevel object for the given xdg_surface and gives the
    /// associated wl_surface the xdg_toplevel role. see the documentation of
    /// xdg_toplevel for more details about what an xdg_toplevel is and how it is used.
    GetToplevel {
        /// (no document).
        id: NewId,
    },
    /// This creates an xdg_popup object for the given xdg_surface and gives the
    /// associated wl_surface the xdg_popup role. if null is passed as a parent, a
    /// parent surface must be specified using some other protocol, before committing
    /// the initial state. see the documentation of xdg_popup for more details about
    /// what an xdg_popup is and how it is used.
    GetPopup {
        /// (no document).
        id: NewId,
        /// (no document).
        parent: Option<XdgSurface>,
        /// (no document).
        positioner: XdgPositioner,
    },
    /// The window geometry of a surface is its "visible bounds" from the user's
    /// perspective. client-side decorations often have invisible portions like drop-
    /// shadows which should be ignored for the purposes of aligning, placing and
    /// constraining windows. the window geometry is double buffered, and will be
    /// applied at the time wl_surface.commit of the corresponding wl_surface is called.
    /// when maintaining a position, the compositor should treat the (x, y) coordinate
    /// of the window geometry as the top left corner of the window. a client changing
    /// the (x, y) window geometry coordinate should in general not alter the position
    /// of the window. once the window geometry of the surface is set, it is not
    /// possible to unset it, and it will remain the same until set_window_geometry is
    /// called again, even if a new subsurface or buffer is attached. if never set, the
    /// value is the full bounds of the surface, including any subsurfaces. this updates
    /// dynamically on every commit. this unset is meant for extremely simple clients.
    /// the arguments are given in the surface-local coordinate space of the wl_surface
    /// associated with this xdg_surface. the width and height must be greater than
    /// zero. setting an invalid size will raise an error. when applied, the effective
    /// window geometry will be the set window geometry clamped to the bounding
    /// rectangle of the combined geometry of the surface of the xdg_surface and the
    /// associated subsurfaces.
    SetWindowGeometry {
        /// (no document).
        x: i32,
        /// (no document).
        y: i32,
        /// (no document).
        width: i32,
        /// (no document).
        height: i32,
    },
    /// When a configure event is received, if a client commits the surface in response
    /// to the configure event, then the client must make an ack_configure request
    /// sometime before the commit request, passing along the serial of the configure
    /// event. for instance, for toplevel surfaces the compositor might use this
    /// information to move a surface to the top left only when the client has drawn
    /// itself for the maximized or fullscreen state. if the client receives multiple
    /// configure events before it can respond to one, it only has to ack the last
    /// configure event. a client is not required to commit immediately after sending an
    /// ack_configure request - it may even ack_configure several times before its next
    /// surface commit. a client may send multiple ack_configure requests before
    /// committing, but only the last request sent before a commit indicates which
    /// configure event the client really is responding to.
    AckConfigure {
        /// The serial from the configure event.
        serial: u32,
    },
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::Destroy {} => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![],
            },
            Request::GetToplevel { id } => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![id.into()],
            },
            Request::GetPopup {
                id,
                parent,
                positioner,
            } => RawMessage {
                sender,
                opcode: Opcode(3),
                args: smallvec![id.into(), parent.into(), positioner.into()],
            },
            Request::SetWindowGeometry {
                x,
                y,
                width,
                height,
            } => RawMessage {
                sender,
                opcode: Opcode(4),
                args: smallvec![x.into(), y.into(), width.into(), height.into()],
            },
            Request::AckConfigure { serial } => RawMessage {
                sender,
                opcode: Opcode(5),
                args: smallvec![serial.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::Destroy {}),
            Opcode(2) => Ok(Request::GetToplevel {
                id: from_payload!(NewId, m.args[0]),
            }),
            Opcode(3) => Ok(Request::GetPopup {
                id: from_payload!(NewId, m.args[0]),

                parent: from_optional_object_payload!(XdgSurface, con.clone(), m.args[1]),

                positioner: from_object_payload!(XdgPositioner, con.clone(), m.args[2]),
            }),
            Opcode(4) => Ok(Request::SetWindowGeometry {
                x: from_payload!(Int, m.args[0]),

                y: from_payload!(Int, m.args[1]),

                width: from_payload!(Int, m.args[2]),

                height: from_payload!(Int, m.args[3]),
            }),
            Opcode(5) => Ok(Request::AckConfigure {
                serial: from_payload!(UInt, m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::XdgSurface(self)
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Error {
    /// (no document).
    NotConstructed = 1,
    /// (no document).
    AlreadyConstructed = 2,
    /// (no document).
    UnconfiguredBuffer = 3,
}

impl Into<Payload> for Error {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Error {
    fn from(value: u32) -> Error {
        match value {
            1 => Error::NotConstructed,
            2 => Error::AlreadyConstructed,
            3 => Error::UnconfiguredBuffer,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {
    /// The configure event marks the end of a configure sequence. a configure sequence
    /// is a set of one or more events configuring the state of the xdg_surface,
    /// including the final xdg_surface.configure event. where applicable, xdg_surface
    /// surface roles will during a configure sequence extend this event as a latched
    /// state sent as events before the xdg_surface.configure event. such events should
    /// be considered to make up a set of atomically applied configuration states, where
    /// the xdg_surface.configure commits the accumulated state. clients should arrange
    /// their surface for the new states, and then send an ack_configure request with
    /// the serial sent in this configure event at some point before committing the new
    /// surface. if the client receives multiple configure events before it can respond
    /// to one, it is free to discard all but the last event it received.
    Configure {
        /// Serial of the configure event.
        serial: u32,
    },
}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Event::Configure { serial } => RawMessage {
                sender,
                opcode: Opcode(6),
                args: smallvec![serial.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            Opcode(6) => Ok(Event::Configure {
                serial: from_payload!(UInt, m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::XdgSurface(XdgSurface::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Desktop user interface surface base interface.
#[derive(Clone)]
pub struct XdgSurface {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for XdgSurface {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for XdgSurface {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "XdgSurface@{}", self.object_id.0)
    }
}

impl Into<Payload> for XdgSurface {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for XdgSurface {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "xdg_surface";
    const VERSION: u32 = 3;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[],
        &[PayloadType::NewId],
        &[
            PayloadType::NewId,
            PayloadType::ObjectId,
            PayloadType::ObjectId,
        ],
        &[
            PayloadType::Int,
            PayloadType::Int,
            PayloadType::Int,
            PayloadType::Int,
        ],
        &[PayloadType::UInt],
        &[PayloadType::UInt],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> XdgSurface {
        XdgSurface { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
