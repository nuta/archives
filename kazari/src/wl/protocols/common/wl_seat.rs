//! A seat is a group of keyboards, pointer and touch devices. this object is
//! published as a global during start up, or when such a device is hot plugged. a
//! seat typically has a pointer and maintains a keyboard focus and a pointer focus.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;

use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// The id provided will be initialized to the wl_pointer interface for this seat.
    /// this request only takes effect if the seat has the pointer capability, or has
    /// had the pointer capability in the past. it is a protocol violation to issue this
    /// request on a seat that has never had the pointer capability. the
    /// missing_capability error will be sent in this case.
    GetPointer {
        /// Seat pointer.
        id: NewId,
    },
    /// The id provided will be initialized to the wl_keyboard interface for this seat.
    /// this request only takes effect if the seat has the keyboard capability, or has
    /// had the keyboard capability in the past. it is a protocol violation to issue
    /// this request on a seat that has never had the keyboard capability. the
    /// missing_capability error will be sent in this case.
    GetKeyboard {
        /// Seat keyboard.
        id: NewId,
    },
    /// The id provided will be initialized to the wl_touch interface for this seat.
    /// this request only takes effect if the seat has the touch capability, or has had
    /// the touch capability in the past. it is a protocol violation to issue this
    /// request on a seat that has never had the touch capability. the
    /// missing_capability error will be sent in this case.
    GetTouch {
        /// Seat touch interface.
        id: NewId,
    },
    /// Using this request a client can tell the server that it is not going to use the
    /// seat object anymore.
    Release {},
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::GetPointer { id } => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![id.into()],
            },
            Request::GetKeyboard { id } => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![id.into()],
            },
            Request::GetTouch { id } => RawMessage {
                sender,
                opcode: Opcode(3),
                args: smallvec![id.into()],
            },
            Request::Release {} => RawMessage {
                sender,
                opcode: Opcode(4),
                args: smallvec![],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::GetPointer {
                id: from_payload!(NewId, m.args[0]),
            }),
            Opcode(2) => Ok(Request::GetKeyboard {
                id: from_payload!(NewId, m.args[0]),
            }),
            Opcode(3) => Ok(Request::GetTouch {
                id: from_payload!(NewId, m.args[0]),
            }),
            Opcode(4) => Ok(Request::Release {}),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::WlSeat(self)
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Capability {
    /// The seat has pointer devices.
    Pointer = 1,
    /// The seat has one or more keyboards.
    Keyboard = 2,
    /// The seat has touch devices.
    Touch = 4,
}

impl Into<Payload> for Capability {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Capability {
    fn from(value: u32) -> Capability {
        match value {
            1 => Capability::Pointer,
            2 => Capability::Keyboard,
            4 => Capability::Touch,

            _ => unreachable!(),
        }
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Error {
    /// Get_pointer, get_keyboard or get_touch called on seat without the matching
    /// capability.
    MissingCapability = 0,
}

impl Into<Payload> for Error {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Error {
    fn from(value: u32) -> Error {
        match value {
            0 => Error::MissingCapability,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {
    /// This is emitted whenever a seat gains or loses the pointer, keyboard or touch
    /// capabilities. the argument is a capability enum containing the complete set of
    /// capabilities this seat has. when the pointer capability is added, a client may
    /// create a wl_pointer object using the wl_seat.get_pointer request. this object
    /// will receive pointer events until the capability is removed in the future. when
    /// the pointer capability is removed, a client should destroy the wl_pointer
    /// objects associated with the seat where the capability was removed, using the
    /// wl_pointer.release request. no further pointer events will be received on these
    /// objects. in some compositors, if a seat regains the pointer capability and a
    /// client has a previously obtained wl_pointer object of version 4 or less, that
    /// object may start sending pointer events again. this behavior is considered a
    /// misinterpretation of the intended behavior and must not be relied upon by the
    /// client. wl_pointer objects of version 5 or later must not send events if created
    /// before the most recent event notifying the client of an added pointer
    /// capability. the above behavior also applies to wl_keyboard and wl_touch with the
    /// keyboard and touch capabilities, respectively.
    Capabilities {
        /// Capabilities of the seat.
        capabilities: Capability,
    },
    /// In a multiseat configuration this can be used by the client to help identify
    /// which physical devices the seat represents. based on the seat configuration used
    /// by the compositor.
    Name {
        /// Seat identifier.
        name: String,
    },
}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Event::Capabilities { capabilities } => RawMessage {
                sender,
                opcode: Opcode(5),
                args: smallvec![capabilities.into()],
            },
            Event::Name { name } => RawMessage {
                sender,
                opcode: Opcode(6),
                args: smallvec![name.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            Opcode(5) => Ok(Event::Capabilities {
                capabilities: from_payload!(UInt, m.args[0]),
            }),
            Opcode(6) => Ok(Event::Name {
                name: from_payload!(String, m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::WlSeat(WlSeat::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Group of input devices.
#[derive(Clone)]
pub struct WlSeat {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for WlSeat {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for WlSeat {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "WlSeat@{}", self.object_id.0)
    }
}

impl Into<Payload> for WlSeat {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for WlSeat {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "wl_seat";
    const VERSION: u32 = 7;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[PayloadType::NewId],
        &[PayloadType::NewId],
        &[PayloadType::NewId],
        &[],
        &[PayloadType::UInt],
        &[PayloadType::String],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> WlSeat {
        WlSeat { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
