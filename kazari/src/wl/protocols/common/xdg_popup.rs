//! A popup surface is a short-lived, temporary surface. it can be used to implement
//! for example menus, popovers, tooltips and other similar user interface concepts.
//! a popup can be made to take an explicit grab. see xdg_popup.grab for details.
//! when the popup is dismissed, a popup_done event will be sent out, and at the
//! same time the surface will be unmapped. see the xdg_popup.popup_done event for
//! details. explicitly destroying the xdg_popup object will also dismiss the popup
//! and unmap the surface. clients that want to dismiss the popup when another
//! surface of their own is clicked should dismiss the popup using the destroy
//! request. a newly created xdg_popup will be stacked on top of all previously
//! created xdg_popup surfaces associated with the same xdg_toplevel. the parent of
//! an xdg_popup must be mapped (see the xdg_surface description) before the
//! xdg_popup itself. the client must call wl_surface.commit on the corresponding
//! wl_surface for the xdg_popup state to take effect.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;

use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// This destroys the popup. explicitly destroying the xdg_popup object will also
    /// dismiss the popup, and unmap the surface. if this xdg_popup is not the "topmost"
    /// popup, a protocol error will be sent.
    Destroy {},
    /// This request makes the created popup take an explicit grab. an explicit grab
    /// will be dismissed when the user dismisses the popup, or when the client destroys
    /// the xdg_popup. this can be done by the user clicking outside the surface, using
    /// the keyboard, or even locking the screen through closing the lid or a timeout.
    /// if the compositor denies the grab, the popup will be immediately dismissed. this
    /// request must be used in response to some sort of user action like a button
    /// press, key press, or touch down event. the serial number of the event should be
    /// passed as 'serial'. the parent of a grabbing popup must either be an
    /// xdg_toplevel surface or another xdg_popup with an explicit grab. if the parent
    /// is another xdg_popup it means that the popups are nested, with this popup now
    /// being the topmost popup. nested popups must be destroyed in the reverse order
    /// they were created in, e.g. the only popup you are allowed to destroy at all
    /// times is the topmost one. when compositors choose to dismiss a popup, they may
    /// dismiss every nested grabbing popup as well. when a compositor dismisses popups,
    /// it will follow the same dismissing order as required from the client. the parent
    /// of a grabbing popup must either be another xdg_popup with an active explicit
    /// grab, or an xdg_popup or xdg_toplevel, if there are no explicit grabs already
    /// taken. if the topmost grabbing popup is destroyed, the grab will be returned to
    /// the parent of the popup, if that parent previously had an explicit grab. if the
    /// parent is a grabbing popup which has already been dismissed, this popup will be
    /// immediately dismissed. if the parent is a popup that did not take an explicit
    /// grab, an error will be raised. during a popup grab, the client owning the grab
    /// will receive pointer and touch events for all their surfaces as normal (similar
    /// to an "owner-events" grab in x11 parlance), while the top most grabbing popup
    /// will always have keyboard focus.
    Grab {
        /// The wl_seat of the user event.
        seat: WlSeat,
        /// The serial of the user event.
        serial: u32,
    },
    /// Reposition an already-mapped popup. the popup will be placed given the details
    /// in the passed xdg_positioner object, and a xdg_popup.repositioned followed by
    /// xdg_popup.configure and xdg_surface.configure will be emitted in response. any
    /// parameters set by the previous positioner will be discarded. the passed token
    /// will be sent in the corresponding xdg_popup.repositioned event. the new popup
    /// position will not take effect until the corresponding configure event is
    /// acknowledged by the client. see xdg_popup.repositioned for details. the token
    /// itself is opaque, and has no other special meaning. if multiple reposition
    /// requests are sent, the compositor may skip all but the last one. if the popup is
    /// repositioned in response to a configure event for its parent, the client should
    /// send an xdg_positioner.set_parent_configure and possibly an
    /// xdg_positioner.set_parent_size request to allow the compositor to properly
    /// constrain the popup. if the popup is repositioned together with a parent that is
    /// being resized, but not in response to a configure event, the client should send
    /// an xdg_positioner.set_parent_size request.
    Reposition {
        /// (no document).
        positioner: XdgPositioner,
        /// Reposition request token.
        token: u32,
    },
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::Destroy {} => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![],
            },
            Request::Grab { seat, serial } => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![seat.into(), serial.into()],
            },
            Request::Reposition { positioner, token } => RawMessage {
                sender,
                opcode: Opcode(3),
                args: smallvec![positioner.into(), token.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::Destroy {}),
            Opcode(2) => Ok(Request::Grab {
                seat: from_object_payload!(WlSeat, con.clone(), m.args[0]),

                serial: from_payload!(UInt, m.args[1]),
            }),
            Opcode(3) => Ok(Request::Reposition {
                positioner: from_object_payload!(XdgPositioner, con.clone(), m.args[0]),

                token: from_payload!(UInt, m.args[1]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::XdgPopup(self)
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Error {
    /// Tried to grab after being mapped.
    InvalidGrab = 0,
}

impl Into<Payload> for Error {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Error {
    fn from(value: u32) -> Error {
        match value {
            0 => Error::InvalidGrab,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {
    /// This event asks the popup surface to configure itself given the configuration.
    /// the configured state should not be applied immediately. see
    /// xdg_surface.configure for details. the x and y arguments represent the position
    /// the popup was placed at given the xdg_positioner rule, relative to the upper
    /// left corner of the window geometry of the parent surface. for version 2 or
    /// older, the configure event for an xdg_popup is only ever sent once for the
    /// initial configuration. starting with version 3, it may be sent again if the
    /// popup is setup with an xdg_positioner with set_reactive requested, or in
    /// response to xdg_popup.reposition requests.
    Configure {
        /// X position relative to parent surface window geometry.
        x: i32,
        /// Y position relative to parent surface window geometry.
        y: i32,
        /// Window geometry width.
        width: i32,
        /// Window geometry height.
        height: i32,
    },
    /// The popup_done event is sent out when a popup is dismissed by the compositor.
    /// the client should destroy the xdg_popup object at this point.
    PopupDone {},
    /// The repositioned event is sent as part of a popup configuration sequence,
    /// together with xdg_popup.configure and lastly xdg_surface.configure to notify the
    /// completion of a reposition request. the repositioned event is to notify about
    /// the completion of a xdg_popup.reposition request. the token argument is the
    /// token passed in the xdg_popup.reposition request. immediately after this event
    /// is emitted, xdg_popup.configure and xdg_surface.configure will be sent with the
    /// updated size and position, as well as a new configure serial. the client should
    /// optionally update the content of the popup, but must acknowledge the new popup
    /// configuration for the new position to take effect. see xdg_surface.ack_configure
    /// for details.
    Repositioned {
        /// Reposition request token.
        token: u32,
    },
}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Event::Configure {
                x,
                y,
                width,
                height,
            } => RawMessage {
                sender,
                opcode: Opcode(4),
                args: smallvec![x.into(), y.into(), width.into(), height.into()],
            },
            Event::PopupDone {} => RawMessage {
                sender,
                opcode: Opcode(5),
                args: smallvec![],
            },
            Event::Repositioned { token } => RawMessage {
                sender,
                opcode: Opcode(6),
                args: smallvec![token.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            Opcode(4) => Ok(Event::Configure {
                x: from_payload!(Int, m.args[0]),

                y: from_payload!(Int, m.args[1]),

                width: from_payload!(Int, m.args[2]),

                height: from_payload!(Int, m.args[3]),
            }),
            Opcode(5) => Ok(Event::PopupDone {}),
            Opcode(6) => Ok(Event::Repositioned {
                token: from_payload!(UInt, m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::XdgPopup(XdgPopup::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Short-lived, popup surfaces for menus.
#[derive(Clone)]
pub struct XdgPopup {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for XdgPopup {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for XdgPopup {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "XdgPopup@{}", self.object_id.0)
    }
}

impl Into<Payload> for XdgPopup {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for XdgPopup {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "xdg_popup";
    const VERSION: u32 = 3;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[],
        &[PayloadType::ObjectId, PayloadType::UInt],
        &[PayloadType::ObjectId, PayloadType::UInt],
        &[
            PayloadType::Int,
            PayloadType::Int,
            PayloadType::Int,
            PayloadType::Int,
        ],
        &[],
        &[PayloadType::UInt],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> XdgPopup {
        XdgPopup { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
