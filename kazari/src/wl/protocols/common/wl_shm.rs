//! A singleton global object that provides support for shared memory. clients can
//! create wl_shm_pool objects using the create_pool request. at connection setup
//! time, the wl_shm object emits one or more format events to inform clients about
//! the valid pixel formats that can be used for buffers.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;

use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// Create a new wl_shm_pool object. the pool can be used to create shared memory
    /// based buffer objects. the server will mmap size bytes of the passed file
    /// descriptor, to use as backing memory for the pool.
    CreatePool {
        /// Pool to create.
        id: NewId,
        /// File descriptor for the pool.
        fd: Handle,
        /// Pool size, in bytes.
        size: i32,
    },
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::CreatePool { id, fd, size } => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![id.into(), fd.into(), size.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::CreatePool {
                id: from_payload!(NewId, m.args[0]),

                fd: from_payload!(Handle, m.args[1]),

                size: from_payload!(Int, m.args[2]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::WlShm(self)
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Error {
    /// Buffer format is not known.
    InvalidFormat = 0,
    /// Invalid size or stride during pool or buffer creation.
    InvalidStride = 1,
    /// Mmapping the file descriptor failed.
    InvalidFd = 2,
}

impl Into<Payload> for Error {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Error {
    fn from(value: u32) -> Error {
        match value {
            0 => Error::InvalidFormat,
            1 => Error::InvalidStride,
            2 => Error::InvalidFd,

            _ => unreachable!(),
        }
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Format {
    /// 32-bit argb format, [31:0] a:r:g:b 8:8:8:8 little endian.
    Argb8888 = 0,
    /// 32-bit rgb format, [31:0] x:r:g:b 8:8:8:8 little endian.
    Xrgb8888 = 1,
    /// 8-bit color index format, [7:0] c.
    C8 = 0x20203843,
    /// 8-bit rgb format, [7:0] r:g:b 3:3:2.
    Rgb332 = 0x38424752,
    /// 8-bit bgr format, [7:0] b:g:r 2:3:3.
    Bgr233 = 0x38524742,
    /// 16-bit xrgb format, [15:0] x:r:g:b 4:4:4:4 little endian.
    Xrgb4444 = 0x32315258,
    /// 16-bit xbgr format, [15:0] x:b:g:r 4:4:4:4 little endian.
    Xbgr4444 = 0x32314258,
    /// 16-bit rgbx format, [15:0] r:g:b:x 4:4:4:4 little endian.
    Rgbx4444 = 0x32315852,
    /// 16-bit bgrx format, [15:0] b:g:r:x 4:4:4:4 little endian.
    Bgrx4444 = 0x32315842,
    /// 16-bit argb format, [15:0] a:r:g:b 4:4:4:4 little endian.
    Argb4444 = 0x32315241,
    /// 16-bit abgr format, [15:0] a:b:g:r 4:4:4:4 little endian.
    Abgr4444 = 0x32314241,
    /// 16-bit rbga format, [15:0] r:g:b:a 4:4:4:4 little endian.
    Rgba4444 = 0x32314152,
    /// 16-bit bgra format, [15:0] b:g:r:a 4:4:4:4 little endian.
    Bgra4444 = 0x32314142,
    /// 16-bit xrgb format, [15:0] x:r:g:b 1:5:5:5 little endian.
    Xrgb1555 = 0x35315258,
    /// 16-bit xbgr 1555 format, [15:0] x:b:g:r 1:5:5:5 little endian.
    Xbgr1555 = 0x35314258,
    /// 16-bit rgbx 5551 format, [15:0] r:g:b:x 5:5:5:1 little endian.
    Rgbx5551 = 0x35315852,
    /// 16-bit bgrx 5551 format, [15:0] b:g:r:x 5:5:5:1 little endian.
    Bgrx5551 = 0x35315842,
    /// 16-bit argb 1555 format, [15:0] a:r:g:b 1:5:5:5 little endian.
    Argb1555 = 0x35315241,
    /// 16-bit abgr 1555 format, [15:0] a:b:g:r 1:5:5:5 little endian.
    Abgr1555 = 0x35314241,
    /// 16-bit rgba 5551 format, [15:0] r:g:b:a 5:5:5:1 little endian.
    Rgba5551 = 0x35314152,
    /// 16-bit bgra 5551 format, [15:0] b:g:r:a 5:5:5:1 little endian.
    Bgra5551 = 0x35314142,
    /// 16-bit rgb 565 format, [15:0] r:g:b 5:6:5 little endian.
    Rgb565 = 0x36314752,
    /// 16-bit bgr 565 format, [15:0] b:g:r 5:6:5 little endian.
    Bgr565 = 0x36314742,
    /// 24-bit rgb format, [23:0] r:g:b little endian.
    Rgb888 = 0x34324752,
    /// 24-bit bgr format, [23:0] b:g:r little endian.
    Bgr888 = 0x34324742,
    /// 32-bit xbgr format, [31:0] x:b:g:r 8:8:8:8 little endian.
    Xbgr8888 = 0x34324258,
    /// 32-bit rgbx format, [31:0] r:g:b:x 8:8:8:8 little endian.
    Rgbx8888 = 0x34325852,
    /// 32-bit bgrx format, [31:0] b:g:r:x 8:8:8:8 little endian.
    Bgrx8888 = 0x34325842,
    /// 32-bit abgr format, [31:0] a:b:g:r 8:8:8:8 little endian.
    Abgr8888 = 0x34324241,
    /// 32-bit rgba format, [31:0] r:g:b:a 8:8:8:8 little endian.
    Rgba8888 = 0x34324152,
    /// 32-bit bgra format, [31:0] b:g:r:a 8:8:8:8 little endian.
    Bgra8888 = 0x34324142,
    /// 32-bit xrgb format, [31:0] x:r:g:b 2:10:10:10 little endian.
    Xrgb2101010 = 0x30335258,
    /// 32-bit xbgr format, [31:0] x:b:g:r 2:10:10:10 little endian.
    Xbgr2101010 = 0x30334258,
    /// 32-bit rgbx format, [31:0] r:g:b:x 10:10:10:2 little endian.
    Rgbx1010102 = 0x30335852,
    /// 32-bit bgrx format, [31:0] b:g:r:x 10:10:10:2 little endian.
    Bgrx1010102 = 0x30335842,
    /// 32-bit argb format, [31:0] a:r:g:b 2:10:10:10 little endian.
    Argb2101010 = 0x30335241,
    /// 32-bit abgr format, [31:0] a:b:g:r 2:10:10:10 little endian.
    Abgr2101010 = 0x30334241,
    /// 32-bit rgba format, [31:0] r:g:b:a 10:10:10:2 little endian.
    Rgba1010102 = 0x30334152,
    /// 32-bit bgra format, [31:0] b:g:r:a 10:10:10:2 little endian.
    Bgra1010102 = 0x30334142,
    /// Packed ycbcr format, [31:0] cr0:y1:cb0:y0 8:8:8:8 little endian.
    Yuyv = 0x56595559,
    /// Packed ycbcr format, [31:0] cb0:y1:cr0:y0 8:8:8:8 little endian.
    Yvyu = 0x55595659,
    /// Packed ycbcr format, [31:0] y1:cr0:y0:cb0 8:8:8:8 little endian.
    Uyvy = 0x59565955,
    /// Packed ycbcr format, [31:0] y1:cb0:y0:cr0 8:8:8:8 little endian.
    Vyuy = 0x59555956,
    /// Packed aycbcr format, [31:0] a:y:cb:cr 8:8:8:8 little endian.
    Ayuv = 0x56555941,
    /// 2 plane ycbcr cr:cb format, 2x2 subsampled cr:cb plane.
    Nv12 = 0x3231564e,
    /// 2 plane ycbcr cb:cr format, 2x2 subsampled cb:cr plane.
    Nv21 = 0x3132564e,
    /// 2 plane ycbcr cr:cb format, 2x1 subsampled cr:cb plane.
    Nv16 = 0x3631564e,
    /// 2 plane ycbcr cb:cr format, 2x1 subsampled cb:cr plane.
    Nv61 = 0x3136564e,
    /// 3 plane ycbcr format, 4x4 subsampled cb (1) and cr (2) planes.
    Yuv410 = 0x39565559,
    /// 3 plane ycbcr format, 4x4 subsampled cr (1) and cb (2) planes.
    Yvu410 = 0x39555659,
    /// 3 plane ycbcr format, 4x1 subsampled cb (1) and cr (2) planes.
    Yuv411 = 0x31315559,
    /// 3 plane ycbcr format, 4x1 subsampled cr (1) and cb (2) planes.
    Yvu411 = 0x31315659,
    /// 3 plane ycbcr format, 2x2 subsampled cb (1) and cr (2) planes.
    Yuv420 = 0x32315559,
    /// 3 plane ycbcr format, 2x2 subsampled cr (1) and cb (2) planes.
    Yvu420 = 0x32315659,
    /// 3 plane ycbcr format, 2x1 subsampled cb (1) and cr (2) planes.
    Yuv422 = 0x36315559,
    /// 3 plane ycbcr format, 2x1 subsampled cr (1) and cb (2) planes.
    Yvu422 = 0x36315659,
    /// 3 plane ycbcr format, non-subsampled cb (1) and cr (2) planes.
    Yuv444 = 0x34325559,
    /// 3 plane ycbcr format, non-subsampled cr (1) and cb (2) planes.
    Yvu444 = 0x34325659,
    /// [7:0] r.
    R8 = 0x20203852,
    /// [15:0] r little endian.
    R16 = 0x20363152,
    /// [15:0] r:g 8:8 little endian.
    Rg88 = 0x38384752,
    /// [15:0] g:r 8:8 little endian.
    Gr88 = 0x38385247,
    /// [31:0] r:g 16:16 little endian.
    Rg1616 = 0x32334752,
    /// [31:0] g:r 16:16 little endian.
    Gr1616 = 0x32335247,
    /// [63:0] x:r:g:b 16:16:16:16 little endian.
    Xrgb16161616F = 0x48345258,
    /// [63:0] x:b:g:r 16:16:16:16 little endian.
    Xbgr16161616F = 0x48344258,
    /// [63:0] a:r:g:b 16:16:16:16 little endian.
    Argb16161616F = 0x48345241,
    /// [63:0] a:b:g:r 16:16:16:16 little endian.
    Abgr16161616F = 0x48344241,
    /// [31:0] x:y:cb:cr 8:8:8:8 little endian.
    Xyuv8888 = 0x56555958,
    /// [23:0] cr:cb:y 8:8:8 little endian.
    Vuy888 = 0x34325556,
    /// Y followed by u then v, 10:10:10. non-linear modifier only.
    Vuy101010 = 0x30335556,
    /// [63:0] cr0:0:y1:0:cb0:0:y0:0 10:6:10:6:10:6:10:6 little endian per 2 y pixels.
    Y210 = 0x30313259,
    /// [63:0] cr0:0:y1:0:cb0:0:y0:0 12:4:12:4:12:4:12:4 little endian per 2 y pixels.
    Y212 = 0x32313259,
    /// [63:0] cr0:y1:cb0:y0 16:16:16:16 little endian per 2 y pixels.
    Y216 = 0x36313259,
    /// [31:0] a:cr:y:cb 2:10:10:10 little endian.
    Y410 = 0x30313459,
    /// [63:0] a:0:cr:0:y:0:cb:0 12:4:12:4:12:4:12:4 little endian.
    Y412 = 0x32313459,
    /// [63:0] a:cr:y:cb 16:16:16:16 little endian.
    Y416 = 0x36313459,
    /// [31:0] x:cr:y:cb 2:10:10:10 little endian.
    Xvyu2101010 = 0x30335658,
    /// [63:0] x:0:cr:0:y:0:cb:0 12:4:12:4:12:4:12:4 little endian.
    Xvyu1216161616 = 0x36335658,
    /// [63:0] x:cr:y:cb 16:16:16:16 little endian.
    Xvyu16161616 = 0x38345658,
    /// [63:0] a3:a2:y3:0:cr0:0:y2:0:a1:a0:y1:0:cb0:0:y0:0
    /// 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian.
    Y0L0 = 0x304c3059,
    /// [63:0] x3:x2:y3:0:cr0:0:y2:0:x1:x0:y1:0:cb0:0:y0:0
    /// 1:1:8:2:8:2:8:2:1:1:8:2:8:2:8:2 little endian.
    X0L0 = 0x304c3058,
    /// [63:0] a3:a2:y3:cr0:y2:a1:a0:y1:cb0:y0 1:1:10:10:10:1:1:10:10:10 little endian.
    Y0L2 = 0x324c3059,
    /// [63:0] x3:x2:y3:cr0:y2:x1:x0:y1:cb0:y0 1:1:10:10:10:1:1:10:10:10 little endian.
    X0L2 = 0x324c3058,
    /// (no document).
    Yuv4208Bit = 0x38305559,
    /// (no document).
    Yuv42010Bit = 0x30315559,
    /// (no document).
    Xrgb8888A8 = 0x38415258,
    /// (no document).
    Xbgr8888A8 = 0x38414258,
    /// (no document).
    Rgbx8888A8 = 0x38415852,
    /// (no document).
    Bgrx8888A8 = 0x38415842,
    /// (no document).
    Rgb888A8 = 0x38413852,
    /// (no document).
    Bgr888A8 = 0x38413842,
    /// (no document).
    Rgb565A8 = 0x38413552,
    /// (no document).
    Bgr565A8 = 0x38413542,
    /// Non-subsampled cr:cb plane.
    Nv24 = 0x3432564e,
    /// Non-subsampled cb:cr plane.
    Nv42 = 0x3234564e,
    /// 2x1 subsampled cr:cb plane, 10 bit per channel.
    P210 = 0x30313250,
    /// 2x2 subsampled cr:cb plane 10 bits per channel.
    P010 = 0x30313050,
    /// 2x2 subsampled cr:cb plane 12 bits per channel.
    P012 = 0x32313050,
    /// 2x2 subsampled cr:cb plane 16 bits per channel.
    P016 = 0x36313050,
    /// [63:0] a:x:b:x:g:x:r:x 10:6:10:6:10:6:10:6 little endian.
    Axbxgxrx106106106106 = 0x30314241,
    /// 2x2 subsampled cr:cb plane.
    Nv15 = 0x3531564e,
    /// (no document).
    Q410 = 0x30313451,
    /// (no document).
    Q401 = 0x31303451,
}

impl Into<Payload> for Format {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Format {
    fn from(value: u32) -> Format {
        match value {
            0 => Format::Argb8888,
            1 => Format::Xrgb8888,
            0x20203843 => Format::C8,
            0x38424752 => Format::Rgb332,
            0x38524742 => Format::Bgr233,
            0x32315258 => Format::Xrgb4444,
            0x32314258 => Format::Xbgr4444,
            0x32315852 => Format::Rgbx4444,
            0x32315842 => Format::Bgrx4444,
            0x32315241 => Format::Argb4444,
            0x32314241 => Format::Abgr4444,
            0x32314152 => Format::Rgba4444,
            0x32314142 => Format::Bgra4444,
            0x35315258 => Format::Xrgb1555,
            0x35314258 => Format::Xbgr1555,
            0x35315852 => Format::Rgbx5551,
            0x35315842 => Format::Bgrx5551,
            0x35315241 => Format::Argb1555,
            0x35314241 => Format::Abgr1555,
            0x35314152 => Format::Rgba5551,
            0x35314142 => Format::Bgra5551,
            0x36314752 => Format::Rgb565,
            0x36314742 => Format::Bgr565,
            0x34324752 => Format::Rgb888,
            0x34324742 => Format::Bgr888,
            0x34324258 => Format::Xbgr8888,
            0x34325852 => Format::Rgbx8888,
            0x34325842 => Format::Bgrx8888,
            0x34324241 => Format::Abgr8888,
            0x34324152 => Format::Rgba8888,
            0x34324142 => Format::Bgra8888,
            0x30335258 => Format::Xrgb2101010,
            0x30334258 => Format::Xbgr2101010,
            0x30335852 => Format::Rgbx1010102,
            0x30335842 => Format::Bgrx1010102,
            0x30335241 => Format::Argb2101010,
            0x30334241 => Format::Abgr2101010,
            0x30334152 => Format::Rgba1010102,
            0x30334142 => Format::Bgra1010102,
            0x56595559 => Format::Yuyv,
            0x55595659 => Format::Yvyu,
            0x59565955 => Format::Uyvy,
            0x59555956 => Format::Vyuy,
            0x56555941 => Format::Ayuv,
            0x3231564e => Format::Nv12,
            0x3132564e => Format::Nv21,
            0x3631564e => Format::Nv16,
            0x3136564e => Format::Nv61,
            0x39565559 => Format::Yuv410,
            0x39555659 => Format::Yvu410,
            0x31315559 => Format::Yuv411,
            0x31315659 => Format::Yvu411,
            0x32315559 => Format::Yuv420,
            0x32315659 => Format::Yvu420,
            0x36315559 => Format::Yuv422,
            0x36315659 => Format::Yvu422,
            0x34325559 => Format::Yuv444,
            0x34325659 => Format::Yvu444,
            0x20203852 => Format::R8,
            0x20363152 => Format::R16,
            0x38384752 => Format::Rg88,
            0x38385247 => Format::Gr88,
            0x32334752 => Format::Rg1616,
            0x32335247 => Format::Gr1616,
            0x48345258 => Format::Xrgb16161616F,
            0x48344258 => Format::Xbgr16161616F,
            0x48345241 => Format::Argb16161616F,
            0x48344241 => Format::Abgr16161616F,
            0x56555958 => Format::Xyuv8888,
            0x34325556 => Format::Vuy888,
            0x30335556 => Format::Vuy101010,
            0x30313259 => Format::Y210,
            0x32313259 => Format::Y212,
            0x36313259 => Format::Y216,
            0x30313459 => Format::Y410,
            0x32313459 => Format::Y412,
            0x36313459 => Format::Y416,
            0x30335658 => Format::Xvyu2101010,
            0x36335658 => Format::Xvyu1216161616,
            0x38345658 => Format::Xvyu16161616,
            0x304c3059 => Format::Y0L0,
            0x304c3058 => Format::X0L0,
            0x324c3059 => Format::Y0L2,
            0x324c3058 => Format::X0L2,
            0x38305559 => Format::Yuv4208Bit,
            0x30315559 => Format::Yuv42010Bit,
            0x38415258 => Format::Xrgb8888A8,
            0x38414258 => Format::Xbgr8888A8,
            0x38415852 => Format::Rgbx8888A8,
            0x38415842 => Format::Bgrx8888A8,
            0x38413852 => Format::Rgb888A8,
            0x38413842 => Format::Bgr888A8,
            0x38413552 => Format::Rgb565A8,
            0x38413542 => Format::Bgr565A8,
            0x3432564e => Format::Nv24,
            0x3234564e => Format::Nv42,
            0x30313250 => Format::P210,
            0x30313050 => Format::P010,
            0x32313050 => Format::P012,
            0x36313050 => Format::P016,
            0x30314241 => Format::Axbxgxrx106106106106,
            0x3531564e => Format::Nv15,
            0x30313451 => Format::Q410,
            0x31303451 => Format::Q401,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {
    /// Informs the client about a valid pixel format that can be used for buffers.
    /// known formats include argb8888 and xrgb8888.
    Format {
        /// Buffer pixel format.
        format: Format,
    },
}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Event::Format { format } => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![format.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            Opcode(2) => Ok(Event::Format {
                format: from_payload!(UInt, m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::WlShm(WlShm::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Shared memory support.
#[derive(Clone)]
pub struct WlShm {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for WlShm {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for WlShm {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "WlShm@{}", self.object_id.0)
    }
}

impl Into<Payload> for WlShm {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for WlShm {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "wl_shm";
    const VERSION: u32 = 1;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[PayloadType::NewId, PayloadType::Handle, PayloadType::Int],
        &[PayloadType::UInt],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> WlShm {
        WlShm { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
