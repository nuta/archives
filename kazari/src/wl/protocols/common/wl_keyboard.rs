//! The wl_keyboard interface represents one or more keyboards associated with a
//! seat.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;

use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// Release the keyboard object.
    Release {},
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::Release {} => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::Release {}),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::WlKeyboard(self)
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum KeymapFormat {
    /// No keymap; client must understand how to interpret the raw keycode.
    NoKeymap = 0,
    /// Libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the
    /// key event keycode.
    XkbV1 = 1,
}

impl Into<Payload> for KeymapFormat {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for KeymapFormat {
    fn from(value: u32) -> KeymapFormat {
        match value {
            0 => KeymapFormat::NoKeymap,
            1 => KeymapFormat::XkbV1,

            _ => unreachable!(),
        }
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum KeyState {
    /// Key is not pressed.
    Released = 0,
    /// Key is pressed.
    Pressed = 1,
}

impl Into<Payload> for KeyState {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for KeyState {
    fn from(value: u32) -> KeyState {
        match value {
            0 => KeyState::Released,
            1 => KeyState::Pressed,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {
    /// This event provides a file descriptor to the client which can be memory-mapped
    /// to provide a keyboard mapping description. from version 7 onwards, the fd must
    /// be mapped with map_private by the recipient, as map_shared may fail.
    Keymap {
        /// Keymap format.
        format: KeymapFormat,
        /// Keymap file descriptor.
        fd: Handle,
        /// Keymap size, in bytes.
        size: u32,
    },
    /// Notification that this seat's keyboard focus is on a certain surface. the
    /// compositor must send the wl_keyboard.modifiers event after this event.
    Enter {
        /// Serial number of the enter event.
        serial: u32,
        /// Surface gaining keyboard focus.
        surface: WlSurface,
        /// The currently pressed keys.
        keys: Array,
    },
    /// Notification that this seat's keyboard focus is no longer on a certain surface.
    /// the leave notification is sent before the enter notification for the new focus.
    /// after this event client must assume that all keys, including modifiers, are
    /// lifted and also it must stop key repeating if there's some going on.
    Leave {
        /// Serial number of the leave event.
        serial: u32,
        /// Surface that lost keyboard focus.
        surface: WlSurface,
    },
    /// A key was pressed or released. the time argument is a timestamp with millisecond
    /// granularity, with an undefined base. the key is a platform-specific key code
    /// that can be interpreted by feeding it to the keyboard mapping (see the keymap
    /// event). if this event produces a change in modifiers, then the resulting
    /// wl_keyboard.modifiers event must be sent after this event.
    Key {
        /// Serial number of the key event.
        serial: u32,
        /// Timestamp with millisecond granularity.
        time: u32,
        /// Key that produced the event.
        key: u32,
        /// Physical state of the key.
        state: KeyState,
    },
    /// Notifies clients that the modifier and/or group state has changed, and it should
    /// update its local state.
    Modifiers {
        /// Serial number of the modifiers event.
        serial: u32,
        /// Depressed modifiers.
        mods_depressed: u32,
        /// Latched modifiers.
        mods_latched: u32,
        /// Locked modifiers.
        mods_locked: u32,
        /// Keyboard layout.
        group: u32,
    },
    /// Informs the client about the keyboard's repeat rate and delay. this event is
    /// sent as soon as the wl_keyboard object has been created, and is guaranteed to be
    /// received by the client before any key press event. negative values for either
    /// rate or delay are illegal. a rate of zero will disable any repeating (regardless
    /// of the value of delay). this event can be sent later on as well with a new value
    /// if necessary, so clients should continue listening for the event past the
    /// creation of wl_keyboard.
    RepeatInfo {
        /// The rate of repeating keys in characters per second.
        rate: i32,
        /// Delay in milliseconds since key down until repeating starts.
        delay: i32,
    },
}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Event::Keymap { format, fd, size } => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![format.into(), fd.into(), size.into()],
            },
            Event::Enter {
                serial,
                surface,
                keys,
            } => RawMessage {
                sender,
                opcode: Opcode(3),
                args: smallvec![serial.into(), surface.into(), keys.into()],
            },
            Event::Leave { serial, surface } => RawMessage {
                sender,
                opcode: Opcode(4),
                args: smallvec![serial.into(), surface.into()],
            },
            Event::Key {
                serial,
                time,
                key,
                state,
            } => RawMessage {
                sender,
                opcode: Opcode(5),
                args: smallvec![serial.into(), time.into(), key.into(), state.into()],
            },
            Event::Modifiers {
                serial,
                mods_depressed,
                mods_latched,
                mods_locked,
                group,
            } => RawMessage {
                sender,
                opcode: Opcode(6),
                args: smallvec![
                    serial.into(),
                    mods_depressed.into(),
                    mods_latched.into(),
                    mods_locked.into(),
                    group.into()
                ],
            },
            Event::RepeatInfo { rate, delay } => RawMessage {
                sender,
                opcode: Opcode(7),
                args: smallvec![rate.into(), delay.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            Opcode(2) => Ok(Event::Keymap {
                format: from_payload!(UInt, m.args[0]),

                fd: from_payload!(Handle, m.args[1]),

                size: from_payload!(UInt, m.args[2]),
            }),
            Opcode(3) => Ok(Event::Enter {
                serial: from_payload!(UInt, m.args[0]),

                surface: from_object_payload!(WlSurface, con.clone(), m.args[1]),

                keys: from_payload!(Array, m.args[2]),
            }),
            Opcode(4) => Ok(Event::Leave {
                serial: from_payload!(UInt, m.args[0]),

                surface: from_object_payload!(WlSurface, con.clone(), m.args[1]),
            }),
            Opcode(5) => Ok(Event::Key {
                serial: from_payload!(UInt, m.args[0]),

                time: from_payload!(UInt, m.args[1]),

                key: from_payload!(UInt, m.args[2]),

                state: from_payload!(UInt, m.args[3]),
            }),
            Opcode(6) => Ok(Event::Modifiers {
                serial: from_payload!(UInt, m.args[0]),

                mods_depressed: from_payload!(UInt, m.args[1]),

                mods_latched: from_payload!(UInt, m.args[2]),

                mods_locked: from_payload!(UInt, m.args[3]),

                group: from_payload!(UInt, m.args[4]),
            }),
            Opcode(7) => Ok(Event::RepeatInfo {
                rate: from_payload!(Int, m.args[0]),

                delay: from_payload!(Int, m.args[1]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::WlKeyboard(WlKeyboard::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Keyboard input device.
#[derive(Clone)]
pub struct WlKeyboard {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for WlKeyboard {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for WlKeyboard {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "WlKeyboard@{}", self.object_id.0)
    }
}

impl Into<Payload> for WlKeyboard {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for WlKeyboard {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "wl_keyboard";
    const VERSION: u32 = 7;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[],
        &[PayloadType::UInt, PayloadType::Handle, PayloadType::UInt],
        &[PayloadType::UInt, PayloadType::ObjectId, PayloadType::Array],
        &[PayloadType::UInt, PayloadType::ObjectId],
        &[
            PayloadType::UInt,
            PayloadType::UInt,
            PayloadType::UInt,
            PayloadType::UInt,
        ],
        &[
            PayloadType::UInt,
            PayloadType::UInt,
            PayloadType::UInt,
            PayloadType::UInt,
            PayloadType::UInt,
        ],
        &[PayloadType::Int, PayloadType::Int],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> WlKeyboard {
        WlKeyboard { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
