//! The wl_data_source object is the source side of a wl_data_offer. it is created
//! by the source client in a data transfer and provides a way to describe the
//! offered data and a way to respond to requests to transfer the data.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;

use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// This request adds a mime type to the set of mime types advertised to targets.
    /// can be called several times to offer multiple types.
    Offer {
        /// Mime type offered by the data source.
        mime_type: String,
    },
    /// Destroy the data source.
    Destroy {},
    /// Sets the actions that the source side client supports for this operation. this
    /// request may trigger wl_data_source.action and wl_data_offer.action events if the
    /// compositor needs to change the selected action. the dnd_actions argument must
    /// contain only values expressed in the wl_data_device_manager.dnd_actions enum,
    /// otherwise it will result in a protocol error. this request must be made once
    /// only, and can only be made on sources used in drag-and-drop, so it must be
    /// performed before wl_data_device.start_drag. attempting to use the source other
    /// than for drag-and-drop will raise a protocol error.
    SetActions {
        /// Actions supported by the data source.
        dnd_actions: super::super::common::wl_data_device_manager::DndAction,
    },
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::Offer { mime_type } => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![mime_type.into()],
            },
            Request::Destroy {} => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![],
            },
            Request::SetActions { dnd_actions } => RawMessage {
                sender,
                opcode: Opcode(3),
                args: smallvec![dnd_actions.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::Offer {
                mime_type: from_payload!(String, m.args[0]),
            }),
            Opcode(2) => Ok(Request::Destroy {}),
            Opcode(3) => Ok(Request::SetActions {
                dnd_actions: from_payload!(UInt, m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::WlDataSource(self)
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Error {
    /// Action mask contains invalid values.
    InvalidActionMask = 0,
    /// Source doesn't accept this request.
    InvalidSource = 1,
}

impl Into<Payload> for Error {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Error {
    fn from(value: u32) -> Error {
        match value {
            0 => Error::InvalidActionMask,
            1 => Error::InvalidSource,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {
    /// Sent when a target accepts pointer_focus or motion events. if a target does not
    /// accept any of the offered types, type is null. used for feedback during drag-
    /// and-drop.
    Target {
        /// Mime type accepted by the target.
        mime_type: Option<String>,
    },
    /// Request for data from the client. send the data as the specified mime type over
    /// the passed file descriptor, then close it.
    Send {
        /// Mime type for the data.
        mime_type: String,
        /// File descriptor for the data.
        fd: Handle,
    },
    /// This data source is no longer valid. there are several reasons why this could
    /// happen: - the data source has been replaced by another data source. - the drag-
    /// and-drop operation was performed, but the drop destination did not accept any of
    /// the mime types offered through wl_data_source.target. - the drag-and-drop
    /// operation was performed, but the drop destination did not select any of the
    /// actions present in the mask offered through wl_data_source.action. - the drag-
    /// and-drop operation was performed but didn't happen over a surface. - the
    /// compositor cancelled the drag-and-drop operation (e.g. compositor dependent
    /// timeouts to avoid stale drag-and-drop transfers). the client should clean up and
    /// destroy this data source. for objects of version 2 or older,
    /// wl_data_source.cancelled will only be emitted if the data source was replaced by
    /// another data source.
    Cancelled {},
    /// The user performed the drop action. this event does not indicate acceptance,
    /// wl_data_source.cancelled may still be emitted afterwards if the drop destination
    /// does not accept any mime type. however, this event might however not be received
    /// if the compositor cancelled the drag-and-drop operation before this event could
    /// happen. note that the data_source may still be used in the future and should not
    /// be destroyed here.
    DndDropPerformed {},
    /// The drop destination finished interoperating with this data source, so the
    /// client is now free to destroy this data source and free all associated data. if
    /// the action used to perform the operation was "move", the source can now delete
    /// the transferred data.
    DndFinished {},
    /// This event indicates the action selected by the compositor after matching the
    /// source/destination side actions. only one action (or none) will be offered here.
    /// this event can be emitted multiple times during the drag-and-drop operation,
    /// mainly in response to destination side changes through
    /// wl_data_offer.set_actions, and as the data device enters/leaves surfaces. it is
    /// only possible to receive this event after wl_data_source.dnd_drop_performed if
    /// the drag-and-drop operation ended in an "ask" action, in which case the final
    /// wl_data_source.action event will happen immediately before
    /// wl_data_source.dnd_finished. compositors may also change the selected action on
    /// the fly, mainly in response to keyboard modifier changes during the drag-and-
    /// drop operation. the most recent action received is always the valid one. the
    /// chosen action may change alongside negotiation (e.g. an "ask" action can turn
    /// into a "move" operation), so the effects of the final action must always be
    /// applied in wl_data_offer.dnd_finished. clients can trigger cursor surface
    /// changes from this point, so they reflect the current action.
    Action {
        /// Action selected by the compositor.
        dnd_action: super::super::common::wl_data_device_manager::DndAction,
    },
}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Event::Target { mime_type } => RawMessage {
                sender,
                opcode: Opcode(4),
                args: smallvec![mime_type.into()],
            },
            Event::Send { mime_type, fd } => RawMessage {
                sender,
                opcode: Opcode(5),
                args: smallvec![mime_type.into(), fd.into()],
            },
            Event::Cancelled {} => RawMessage {
                sender,
                opcode: Opcode(6),
                args: smallvec![],
            },
            Event::DndDropPerformed {} => RawMessage {
                sender,
                opcode: Opcode(7),
                args: smallvec![],
            },
            Event::DndFinished {} => RawMessage {
                sender,
                opcode: Opcode(8),
                args: smallvec![],
            },
            Event::Action { dnd_action } => RawMessage {
                sender,
                opcode: Opcode(9),
                args: smallvec![dnd_action.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            Opcode(4) => Ok(Event::Target {
                mime_type: from_payload!(String, m.args[0]),
            }),
            Opcode(5) => Ok(Event::Send {
                mime_type: from_payload!(String, m.args[0]),

                fd: from_payload!(Handle, m.args[1]),
            }),
            Opcode(6) => Ok(Event::Cancelled {}),
            Opcode(7) => Ok(Event::DndDropPerformed {}),
            Opcode(8) => Ok(Event::DndFinished {}),
            Opcode(9) => Ok(Event::Action {
                dnd_action: from_payload!(UInt, m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::WlDataSource(WlDataSource::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Offer to transfer data.
#[derive(Clone)]
pub struct WlDataSource {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for WlDataSource {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for WlDataSource {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "WlDataSource@{}", self.object_id.0)
    }
}

impl Into<Payload> for WlDataSource {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for WlDataSource {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "wl_data_source";
    const VERSION: u32 = 3;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[PayloadType::String],
        &[],
        &[PayloadType::UInt],
        &[PayloadType::String],
        &[PayloadType::String, PayloadType::Handle],
        &[],
        &[],
        &[],
        &[PayloadType::UInt],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> WlDataSource {
        WlDataSource { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
