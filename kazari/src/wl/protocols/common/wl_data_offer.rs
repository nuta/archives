//! A wl_data_offer represents a piece of data offered for transfer by another
//! client (the source client). it is used by the copy-and-paste and drag-and-drop
//! mechanisms. the offer describes the different mime types that the data can be
//! converted to and provides the mechanism for transferring the data directly from
//! the source client.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::protocols::common::{EventSet, RequestSet};
use crate::wl::{
    Array, Connection, DeserializeError, Handle, Interface, Message, NewId, ObjectId, Opcode,
    Payload, PayloadType, RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;

use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

macro_rules! from_optional_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => None,
            Payload::ObjectId(id) => Some($ty::new($con, id)),
            _ => return Err(DeserializeError::UnexpectedType), // Abort deserializing.
        }
    };
}

macro_rules! from_object_payload {
    ($ty:ident, $con:expr, $v:expr) => {
        match ($v).clone() {
            Payload::ObjectId(id) if id.is_null() => return Err(DeserializeError::ObjectIsNull),
            Payload::ObjectId(id) => $ty::new($con, id),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

macro_rules! from_payload {
    ($ty:ident, $v:expr) => {
        match ($v).clone() {
            Payload::$ty(value) => value.into(),
            _ => return Err(DeserializeError::UnexpectedType),
        }
    };
}

#[derive(Debug)]
pub enum Request {
    /// Indicate that the client can accept the given mime type, or null for not
    /// accepted. for objects of version 2 or older, this request is used by the client
    /// to give feedback whether the client can receive the given mime type, or null if
    /// none is accepted; the feedback does not determine whether the drag-and-drop
    /// operation succeeds or not. for objects of version 3 or newer, this request
    /// determines the final result of the drag-and-drop operation. if the end result is
    /// that no mime types were accepted, the drag-and-drop operation will be cancelled
    /// and the corresponding drag source will receive wl_data_source.cancelled. clients
    /// may still use this event in conjunction with wl_data_source.action for feedback.
    Accept {
        /// Serial number of the accept request.
        serial: u32,
        /// Mime type accepted by the client.
        mime_type: Option<String>,
    },
    /// To transfer the offered data, the client issues this request and indicates the
    /// mime type it wants to receive. the transfer happens through the passed file
    /// descriptor (typically created with the pipe system call). the source client
    /// writes the data in the mime type representation requested and then closes the
    /// file descriptor. the receiving client reads from the read end of the pipe until
    /// eof and then closes its end, at which point the transfer is complete. this
    /// request may happen multiple times for different mime types, both before and
    /// after wl_data_device.drop. drag-and-drop destination clients may preemptively
    /// fetch data or examine it more closely to determine acceptance.
    Receive {
        /// Mime type desired by receiver.
        mime_type: String,
        /// File descriptor for data transfer.
        fd: Handle,
    },
    /// Destroy the data offer.
    Destroy {},
    /// Notifies the compositor that the drag destination successfully finished the
    /// drag-and-drop operation. upon receiving this request, the compositor will emit
    /// wl_data_source.dnd_finished on the drag source client. it is a client error to
    /// perform other requests than wl_data_offer.destroy after this one. it is also an
    /// error to perform this request after a null mime type has been set in
    /// wl_data_offer.accept or no action was received through wl_data_offer.action. if
    /// wl_data_offer.finish request is received for a non drag and drop operation, the
    /// invalid_finish protocol error is raised.
    Finish {},
    /// Sets the actions that the destination side client supports for this operation.
    /// this request may trigger the emission of wl_data_source.action and
    /// wl_data_offer.action events if the compositor needs to change the selected
    /// action. this request can be called multiple times throughout the drag-and-drop
    /// operation, typically in response to wl_data_device.enter or
    /// wl_data_device.motion events. this request determines the final result of the
    /// drag-and-drop operation. if the end result is that no action is accepted, the
    /// drag source will receive wl_data_source.cancelled. the dnd_actions argument must
    /// contain only values expressed in the wl_data_device_manager.dnd_actions enum,
    /// and the preferred_action argument must only contain one of those values set,
    /// otherwise it will result in a protocol error. while managing an "ask" action,
    /// the destination drag-and-drop client may perform further wl_data_offer.receive
    /// requests, and is expected to perform one last wl_data_offer.set_actions request
    /// with a preferred action other than "ask" (and optionally wl_data_offer.accept)
    /// before requesting wl_data_offer.finish, in order to convey the action selected
    /// by the user. if the preferred action is not in the wl_data_offer.source_actions
    /// mask, an error will be raised. if the "ask" action is dismissed (e.g. user
    /// cancellation), the client is expected to perform wl_data_offer.destroy right
    /// away. this request can only be made on drag-and-drop offers, a protocol error
    /// will be raised otherwise.
    SetActions {
        /// Actions supported by the destination client.
        dnd_actions: super::super::common::wl_data_device_manager::DndAction,
        /// Action preferred by the destination client.
        preferred_action: super::super::common::wl_data_device_manager::DndAction,
    },
}

impl Message for Request {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Request::Accept { serial, mime_type } => RawMessage {
                sender,
                opcode: Opcode(1),
                args: smallvec![serial.into(), mime_type.into()],
            },
            Request::Receive { mime_type, fd } => RawMessage {
                sender,
                opcode: Opcode(2),
                args: smallvec![mime_type.into(), fd.into()],
            },
            Request::Destroy {} => RawMessage {
                sender,
                opcode: Opcode(3),
                args: smallvec![],
            },
            Request::Finish {} => RawMessage {
                sender,
                opcode: Opcode(4),
                args: smallvec![],
            },
            Request::SetActions {
                dnd_actions,
                preferred_action,
            } => RawMessage {
                sender,
                opcode: Opcode(5),
                args: smallvec![dnd_actions.into(), preferred_action.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Request, DeserializeError> {
        match m.opcode {
            Opcode(1) => Ok(Request::Accept {
                serial: from_payload!(UInt, m.args[0]),

                mime_type: from_payload!(String, m.args[1]),
            }),
            Opcode(2) => Ok(Request::Receive {
                mime_type: from_payload!(String, m.args[0]),

                fd: from_payload!(Handle, m.args[1]),
            }),
            Opcode(3) => Ok(Request::Destroy {}),
            Opcode(4) => Ok(Request::Finish {}),
            Opcode(5) => Ok(Request::SetActions {
                dnd_actions: from_payload!(UInt, m.args[0]),

                preferred_action: from_payload!(UInt, m.args[1]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        panic!("not a event!");
    }

    fn into_received_request(self) -> RequestSet {
        RequestSet::WlDataOffer(self)
    }
}

#[repr(u32)]
#[derive(Copy, Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum Error {
    /// Finish request was called untimely.
    InvalidFinish = 0,
    /// Action mask contains invalid values.
    InvalidActionMask = 1,
    /// Action argument has an invalid value.
    InvalidAction = 2,
    /// Offer doesn't accept this request.
    InvalidOffer = 3,
}

impl Into<Payload> for Error {
    fn into(self) -> Payload {
        Payload::UInt(self as u32)
    }
}

impl From<u32> for Error {
    fn from(value: u32) -> Error {
        match value {
            0 => Error::InvalidFinish,
            1 => Error::InvalidActionMask,
            2 => Error::InvalidAction,
            3 => Error::InvalidOffer,

            _ => unreachable!(),
        }
    }
}

#[derive(Debug)]
pub enum Event {
    /// Sent immediately after creating the wl_data_offer object. one event per offered
    /// mime type.
    Offer {
        /// Offered mime type.
        mime_type: String,
    },
    /// This event indicates the actions offered by the data source. it will be sent
    /// right after wl_data_device.enter, or anytime the source side changes its offered
    /// actions through wl_data_source.set_actions.
    SourceActions {
        /// Actions offered by the data source.
        source_actions: super::super::common::wl_data_device_manager::DndAction,
    },
    /// This event indicates the action selected by the compositor after matching the
    /// source/destination side actions. only one action (or none) will be offered here.
    /// this event can be emitted multiple times during the drag-and-drop operation in
    /// response to destination side action changes through wl_data_offer.set_actions.
    /// this event will no longer be emitted after wl_data_device.drop happened on the
    /// drag-and-drop destination, the client must honor the last action received, or
    /// the last preferred one set through wl_data_offer.set_actions when handling an
    /// "ask" action. compositors may also change the selected action on the fly, mainly
    /// in response to keyboard modifier changes during the drag-and-drop operation. the
    /// most recent action received is always the valid one. prior to receiving
    /// wl_data_device.drop, the chosen action may change (e.g. due to keyboard
    /// modifiers being pressed). at the time of receiving wl_data_device.drop the drag-
    /// and-drop destination must honor the last action received. action changes may
    /// still happen after wl_data_device.drop, especially on "ask" actions, where the
    /// drag-and-drop destination may choose another action afterwards. action changes
    /// happening at this stage are always the result of inter-client negotiation, the
    /// compositor shall no longer be able to induce a different action. upon "ask"
    /// actions, it is expected that the drag-and-drop destination may potentially
    /// choose a different action and/or mime type, based on
    /// wl_data_offer.source_actions and finally chosen by the user (e.g. popping up a
    /// menu with the available options). the final wl_data_offer.set_actions and
    /// wl_data_offer.accept requests must happen before the call to
    /// wl_data_offer.finish.
    Action {
        /// Action selected by the compositor.
        dnd_action: super::super::common::wl_data_device_manager::DndAction,
    },
}

impl Message for Event {
    fn into_raw(self, sender: ObjectId) -> RawMessage {
        match self {
            Event::Offer { mime_type } => RawMessage {
                sender,
                opcode: Opcode(6),
                args: smallvec![mime_type.into()],
            },
            Event::SourceActions { source_actions } => RawMessage {
                sender,
                opcode: Opcode(7),
                args: smallvec![source_actions.into()],
            },
            Event::Action { dnd_action } => RawMessage {
                sender,
                opcode: Opcode(8),
                args: smallvec![dnd_action.into()],
            },
        }
    }

    fn from_raw(
        con: Rc<RefCell<dyn Connection>>,
        m: &RawMessage,
    ) -> Result<Event, DeserializeError> {
        match m.opcode {
            Opcode(6) => Ok(Event::Offer {
                mime_type: from_payload!(String, m.args[0]),
            }),
            Opcode(7) => Ok(Event::SourceActions {
                source_actions: from_payload!(UInt, m.args[0]),
            }),
            Opcode(8) => Ok(Event::Action {
                dnd_action: from_payload!(UInt, m.args[0]),
            }),

            _ => Err(DeserializeError::UnknownOpcode),
        }
    }

    fn into_received_event(self, con: Rc<RefCell<dyn Connection>>, id: ObjectId) -> EventSet {
        EventSet::WlDataOffer(WlDataOffer::new(con, id), self)
    }

    fn into_received_request(self) -> RequestSet {
        panic!("not a request!");
    }
}

/// Offer to transfer data.
#[derive(Clone)]
pub struct WlDataOffer {
    con: Rc<RefCell<dyn Connection>>,
    object_id: ObjectId,
}

impl PartialEq for WlDataOffer {
    fn eq(&self, other: &Self) -> bool {
        self.id() == other.id()
    }
}

impl core::fmt::Debug for WlDataOffer {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        write!(f, "WlDataOffer@{}", self.object_id.0)
    }
}

impl Into<Payload> for WlDataOffer {
    fn into(self) -> Payload {
        Payload::ObjectId(self.id())
    }
}

impl Interface for WlDataOffer {
    type Event = Event;
    type Request = Request;
    const NAME: &'static str = "wl_data_offer";
    const VERSION: u32 = 3;
    const PAYLOAD_TYPES: &'static [&'static [PayloadType]] = &[
        &[PayloadType::UInt, PayloadType::String],
        &[PayloadType::String, PayloadType::Handle],
        &[],
        &[],
        &[PayloadType::UInt, PayloadType::UInt],
        &[PayloadType::String],
        &[PayloadType::UInt],
        &[PayloadType::UInt],
    ];

    fn new(con: Rc<RefCell<dyn Connection>>, object_id: ObjectId) -> WlDataOffer {
        WlDataOffer { con, object_id }
    }

    fn connection(&self) -> &Rc<RefCell<dyn Connection>> {
        &self.con
    }

    fn id(&self) -> ObjectId {
        self.object_id
    }

    fn as_new_id(&self) -> NewId {
        NewId(self.object_id.0)
    }
}
