//! This interface defines an xdg_surface role which allows a surface to, among
//! other things, set window-like properties such as maximize, fullscreen, and
//! minimize, set application-specific metadata like title and id, and well as
//! trigger user interactive operations such as interactive resize and move.
//! unmapping an xdg_toplevel means that the surface cannot be shown by the
//! compositor until it is explicitly mapped again. all active operations (e.g.,
//! move, resize) are canceled and all attributes (e.g. title, state, stacking, ...)
//! are discarded for an xdg_toplevel surface when it is unmapped. the xdg_toplevel
//! returns to the state it had right after xdg_surface.get_toplevel. the client can
//! re-map the toplevel by perfoming a commit without any buffer attached, waiting
//! for a configure event and handling it as usual (see xdg_surface description).
//! attaching a null buffer to a toplevel unmaps the surface.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;

use crate::wl::protocols::common::xdg_toplevel::*;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait XdgToplevelExt {
    /// This configure event asks the client to resize its toplevel surface or to change
    /// its state. the configured state should not be applied immediately. see
    /// xdg_surface.configure for details. the width and height arguments specify a hint
    /// to the window about how its surface should be resized in window geometry
    /// coordinates. see set_window_geometry. if the width or height arguments are zero,
    /// it means the client should decide its own window dimension. this may happen when
    /// the compositor needs to configure the state of the surface but doesn't have any
    /// information about any previous or expected dimension. the states listed in the
    /// event specify how the width/height arguments should be interpreted, and possibly
    /// how it should be drawn. clients must send an ack_configure in response to this
    /// event. see xdg_surface.configure and xdg_surface.ack_configure for details.
    fn configure(&self, width: i32, height: i32, states: Array) -> Result<(), SendError>;
    /// The close event is sent by the compositor when the user wants the surface to be
    /// closed. this should be equivalent to the user clicking the close button in
    /// client-side decorations, if your application has any. this is only a request
    /// that the user intends to close the window. the client may choose to ignore this
    /// request, or show a dialog to ask the user to save their data, etc.
    fn close(&self) -> Result<(), SendError>;
}

impl XdgToplevelExt for XdgToplevel {
    /// This configure event asks the client to resize its toplevel surface or to change
    /// its state. the configured state should not be applied immediately. see
    /// xdg_surface.configure for details. the width and height arguments specify a hint
    /// to the window about how its surface should be resized in window geometry
    /// coordinates. see set_window_geometry. if the width or height arguments are zero,
    /// it means the client should decide its own window dimension. this may happen when
    /// the compositor needs to configure the state of the surface but doesn't have any
    /// information about any previous or expected dimension. the states listed in the
    /// event specify how the width/height arguments should be interpreted, and possibly
    /// how it should be drawn. clients must send an ack_configure in response to this
    /// event. see xdg_surface.configure and xdg_surface.ack_configure for details.
    fn configure(&self, width: i32, height: i32, states: Array) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Event::Configure {
                width,
                height,
                states,
            }
            .into_raw(self.id()),
        )
    }
    /// The close event is sent by the compositor when the user wants the surface to be
    /// closed. this should be equivalent to the user clicking the close button in
    /// client-side decorations, if your application has any. this is only a request
    /// that the user intends to close the window. the client may choose to ignore this
    /// request, or show a dialog to ask the user to save their data, etc.
    fn close(&self) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::Close {}.into_raw(self.id()))
    }
}
