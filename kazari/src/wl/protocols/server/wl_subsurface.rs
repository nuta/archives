//! An additional interface to a wl_surface object, which has been made a sub-
//! surface. a sub-surface has one parent surface. a sub-surface's size and position
//! are not limited to that of the parent. particularly, a sub-surface is not
//! automatically clipped to its parent's area. a sub-surface becomes mapped, when a
//! non-null wl_buffer is applied and the parent surface is mapped. the order of
//! which one happens first is irrelevant. a sub-surface is hidden if the parent
//! becomes hidden, or if a null wl_buffer is applied. these rules apply recursively
//! through the tree of surfaces. the behaviour of a wl_surface.commit request on a
//! sub-surface depends on the sub-surface's mode. the possible modes are
//! synchronized and desynchronized, see methods wl_subsurface.set_sync and
//! wl_subsurface.set_desync. synchronized mode caches the wl_surface state to be
//! applied when the parent's state gets applied, and desynchronized mode applies
//! the pending wl_surface state directly. a sub-surface is initially in the
//! synchronized mode. sub-surfaces also have another kind of state, which is
//! managed by wl_subsurface requests, as opposed to wl_surface requests. this state
//! includes the sub-surface position relative to the parent surface
//! (wl_subsurface.set_position), and the stacking order of the parent and its sub-
//! surfaces (wl_subsurface.place_above and .place_below). this state is applied
//! when the parent surface's wl_surface state is applied, regardless of the sub-
//! surface's mode. as the exception, set_sync and set_desync are effective
//! immediately. the main surface can be thought to be always in desynchronized
//! mode, since it does not have a parent in the sub-surfaces sense. even if a sub-
//! surface is in desynchronized mode, it will behave as in synchronized mode, if
//! its parent surface behaves as in synchronized mode. this rule is applied
//! recursively throughout the tree of surfaces. this means, that one can set a sub-
//! surface into synchronized mode, and then assume that all its child and grand-
//! child sub-surfaces are synchronized, too, without explicitly setting them. if
//! the wl_surface associated with the wl_subsurface is destroyed, the wl_subsurface
//! object becomes inert. note, that destroying either object takes effect
//! immediately. if you need to synchronize the removal of a sub-surface to the
//! parent surface update, unmap the sub-surface first by attaching a null
//! wl_buffer, update parent, and then destroy the sub-surface. if the parent
//! wl_surface object is destroyed, the sub-surface is unmapped.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;

use crate::wl::protocols::common::wl_subsurface::*;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait WlSubsurfaceExt {}

impl WlSubsurfaceExt for WlSubsurface {}
