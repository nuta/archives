//! The wl_keyboard interface represents one or more keyboards associated with a
//! seat.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;

use crate::wl::protocols::common::wl_keyboard::*;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait WlKeyboardExt {
    /// This event provides a file descriptor to the client which can be memory-mapped
    /// to provide a keyboard mapping description. from version 7 onwards, the fd must
    /// be mapped with map_private by the recipient, as map_shared may fail.
    fn keymap(&self, format: KeymapFormat, fd: Handle, size: u32) -> Result<(), SendError>;
    /// Notification that this seat's keyboard focus is on a certain surface. the
    /// compositor must send the wl_keyboard.modifiers event after this event.
    fn enter(&self, serial: u32, surface: WlSurface, keys: Array) -> Result<(), SendError>;
    /// Notification that this seat's keyboard focus is no longer on a certain surface.
    /// the leave notification is sent before the enter notification for the new focus.
    /// after this event client must assume that all keys, including modifiers, are
    /// lifted and also it must stop key repeating if there's some going on.
    fn leave(&self, serial: u32, surface: WlSurface) -> Result<(), SendError>;
    /// A key was pressed or released. the time argument is a timestamp with millisecond
    /// granularity, with an undefined base. the key is a platform-specific key code
    /// that can be interpreted by feeding it to the keyboard mapping (see the keymap
    /// event). if this event produces a change in modifiers, then the resulting
    /// wl_keyboard.modifiers event must be sent after this event.
    fn key(&self, serial: u32, time: u32, key: u32, state: KeyState) -> Result<(), SendError>;
    /// Notifies clients that the modifier and/or group state has changed, and it should
    /// update its local state.
    fn modifiers(
        &self,
        serial: u32,
        mods_depressed: u32,
        mods_latched: u32,
        mods_locked: u32,
        group: u32,
    ) -> Result<(), SendError>;
    /// Informs the client about the keyboard's repeat rate and delay. this event is
    /// sent as soon as the wl_keyboard object has been created, and is guaranteed to be
    /// received by the client before any key press event. negative values for either
    /// rate or delay are illegal. a rate of zero will disable any repeating (regardless
    /// of the value of delay). this event can be sent later on as well with a new value
    /// if necessary, so clients should continue listening for the event past the
    /// creation of wl_keyboard.
    fn repeat_info(&self, rate: i32, delay: i32) -> Result<(), SendError>;
}

impl WlKeyboardExt for WlKeyboard {
    /// This event provides a file descriptor to the client which can be memory-mapped
    /// to provide a keyboard mapping description. from version 7 onwards, the fd must
    /// be mapped with map_private by the recipient, as map_shared may fail.
    fn keymap(&self, format: KeymapFormat, fd: Handle, size: u32) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::Keymap { format, fd, size }.into_raw(self.id()))
    }
    /// Notification that this seat's keyboard focus is on a certain surface. the
    /// compositor must send the wl_keyboard.modifiers event after this event.
    fn enter(&self, serial: u32, surface: WlSurface, keys: Array) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Event::Enter {
                serial,
                surface,
                keys,
            }
            .into_raw(self.id()),
        )
    }
    /// Notification that this seat's keyboard focus is no longer on a certain surface.
    /// the leave notification is sent before the enter notification for the new focus.
    /// after this event client must assume that all keys, including modifiers, are
    /// lifted and also it must stop key repeating if there's some going on.
    fn leave(&self, serial: u32, surface: WlSurface) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::Leave { serial, surface }.into_raw(self.id()))
    }
    /// A key was pressed or released. the time argument is a timestamp with millisecond
    /// granularity, with an undefined base. the key is a platform-specific key code
    /// that can be interpreted by feeding it to the keyboard mapping (see the keymap
    /// event). if this event produces a change in modifiers, then the resulting
    /// wl_keyboard.modifiers event must be sent after this event.
    fn key(&self, serial: u32, time: u32, key: u32, state: KeyState) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Event::Key {
                serial,
                time,
                key,
                state,
            }
            .into_raw(self.id()),
        )
    }
    /// Notifies clients that the modifier and/or group state has changed, and it should
    /// update its local state.
    fn modifiers(
        &self,
        serial: u32,
        mods_depressed: u32,
        mods_latched: u32,
        mods_locked: u32,
        group: u32,
    ) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Event::Modifiers {
                serial,
                mods_depressed,
                mods_latched,
                mods_locked,
                group,
            }
            .into_raw(self.id()),
        )
    }
    /// Informs the client about the keyboard's repeat rate and delay. this event is
    /// sent as soon as the wl_keyboard object has been created, and is guaranteed to be
    /// received by the client before any key press event. negative values for either
    /// rate or delay are illegal. a rate of zero will disable any repeating (regardless
    /// of the value of delay). this event can be sent later on as well with a new value
    /// if necessary, so clients should continue listening for the event past the
    /// creation of wl_keyboard.
    fn repeat_info(&self, rate: i32, delay: i32) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::RepeatInfo { rate, delay }.into_raw(self.id()))
    }
}
