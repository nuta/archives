//! The wl_data_source object is the source side of a wl_data_offer. it is created
//! by the source client in a data transfer and provides a way to describe the
//! offered data and a way to respond to requests to transfer the data.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;

use crate::wl::protocols::common::wl_data_source::*;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait WlDataSourceExt {
    /// Sent when a target accepts pointer_focus or motion events. if a target does not
    /// accept any of the offered types, type is null. used for feedback during drag-
    /// and-drop.
    fn target(&self, mime_type: Option<String>) -> Result<(), SendError>;
    /// Request for data from the client. send the data as the specified mime type over
    /// the passed file descriptor, then close it.
    fn send(&self, mime_type: String, fd: Handle) -> Result<(), SendError>;
    /// This data source is no longer valid. there are several reasons why this could
    /// happen: - the data source has been replaced by another data source. - the drag-
    /// and-drop operation was performed, but the drop destination did not accept any of
    /// the mime types offered through wl_data_source.target. - the drag-and-drop
    /// operation was performed, but the drop destination did not select any of the
    /// actions present in the mask offered through wl_data_source.action. - the drag-
    /// and-drop operation was performed but didn't happen over a surface. - the
    /// compositor cancelled the drag-and-drop operation (e.g. compositor dependent
    /// timeouts to avoid stale drag-and-drop transfers). the client should clean up and
    /// destroy this data source. for objects of version 2 or older,
    /// wl_data_source.cancelled will only be emitted if the data source was replaced by
    /// another data source.
    fn cancelled(&self) -> Result<(), SendError>;
    /// The user performed the drop action. this event does not indicate acceptance,
    /// wl_data_source.cancelled may still be emitted afterwards if the drop destination
    /// does not accept any mime type. however, this event might however not be received
    /// if the compositor cancelled the drag-and-drop operation before this event could
    /// happen. note that the data_source may still be used in the future and should not
    /// be destroyed here.
    fn dnd_drop_performed(&self) -> Result<(), SendError>;
    /// The drop destination finished interoperating with this data source, so the
    /// client is now free to destroy this data source and free all associated data. if
    /// the action used to perform the operation was "move", the source can now delete
    /// the transferred data.
    fn dnd_finished(&self) -> Result<(), SendError>;
    /// This event indicates the action selected by the compositor after matching the
    /// source/destination side actions. only one action (or none) will be offered here.
    /// this event can be emitted multiple times during the drag-and-drop operation,
    /// mainly in response to destination side changes through
    /// wl_data_offer.set_actions, and as the data device enters/leaves surfaces. it is
    /// only possible to receive this event after wl_data_source.dnd_drop_performed if
    /// the drag-and-drop operation ended in an "ask" action, in which case the final
    /// wl_data_source.action event will happen immediately before
    /// wl_data_source.dnd_finished. compositors may also change the selected action on
    /// the fly, mainly in response to keyboard modifier changes during the drag-and-
    /// drop operation. the most recent action received is always the valid one. the
    /// chosen action may change alongside negotiation (e.g. an "ask" action can turn
    /// into a "move" operation), so the effects of the final action must always be
    /// applied in wl_data_offer.dnd_finished. clients can trigger cursor surface
    /// changes from this point, so they reflect the current action.
    fn action(
        &self,
        dnd_action: super::super::common::wl_data_device_manager::DndAction,
    ) -> Result<(), SendError>;
}

impl WlDataSourceExt for WlDataSource {
    /// Sent when a target accepts pointer_focus or motion events. if a target does not
    /// accept any of the offered types, type is null. used for feedback during drag-
    /// and-drop.
    fn target(&self, mime_type: Option<String>) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::Target { mime_type }.into_raw(self.id()))
    }
    /// Request for data from the client. send the data as the specified mime type over
    /// the passed file descriptor, then close it.
    fn send(&self, mime_type: String, fd: Handle) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::Send { mime_type, fd }.into_raw(self.id()))
    }
    /// This data source is no longer valid. there are several reasons why this could
    /// happen: - the data source has been replaced by another data source. - the drag-
    /// and-drop operation was performed, but the drop destination did not accept any of
    /// the mime types offered through wl_data_source.target. - the drag-and-drop
    /// operation was performed, but the drop destination did not select any of the
    /// actions present in the mask offered through wl_data_source.action. - the drag-
    /// and-drop operation was performed but didn't happen over a surface. - the
    /// compositor cancelled the drag-and-drop operation (e.g. compositor dependent
    /// timeouts to avoid stale drag-and-drop transfers). the client should clean up and
    /// destroy this data source. for objects of version 2 or older,
    /// wl_data_source.cancelled will only be emitted if the data source was replaced by
    /// another data source.
    fn cancelled(&self) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::Cancelled {}.into_raw(self.id()))
    }
    /// The user performed the drop action. this event does not indicate acceptance,
    /// wl_data_source.cancelled may still be emitted afterwards if the drop destination
    /// does not accept any mime type. however, this event might however not be received
    /// if the compositor cancelled the drag-and-drop operation before this event could
    /// happen. note that the data_source may still be used in the future and should not
    /// be destroyed here.
    fn dnd_drop_performed(&self) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::DndDropPerformed {}.into_raw(self.id()))
    }
    /// The drop destination finished interoperating with this data source, so the
    /// client is now free to destroy this data source and free all associated data. if
    /// the action used to perform the operation was "move", the source can now delete
    /// the transferred data.
    fn dnd_finished(&self) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::DndFinished {}.into_raw(self.id()))
    }
    /// This event indicates the action selected by the compositor after matching the
    /// source/destination side actions. only one action (or none) will be offered here.
    /// this event can be emitted multiple times during the drag-and-drop operation,
    /// mainly in response to destination side changes through
    /// wl_data_offer.set_actions, and as the data device enters/leaves surfaces. it is
    /// only possible to receive this event after wl_data_source.dnd_drop_performed if
    /// the drag-and-drop operation ended in an "ask" action, in which case the final
    /// wl_data_source.action event will happen immediately before
    /// wl_data_source.dnd_finished. compositors may also change the selected action on
    /// the fly, mainly in response to keyboard modifier changes during the drag-and-
    /// drop operation. the most recent action received is always the valid one. the
    /// chosen action may change alongside negotiation (e.g. an "ask" action can turn
    /// into a "move" operation), so the effects of the final action must always be
    /// applied in wl_data_offer.dnd_finished. clients can trigger cursor surface
    /// changes from this point, so they reflect the current action.
    fn action(
        &self,
        dnd_action: super::super::common::wl_data_device_manager::DndAction,
    ) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::Action { dnd_action }.into_raw(self.id()))
    }
}
