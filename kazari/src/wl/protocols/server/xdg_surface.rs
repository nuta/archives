//! An interface that may be implemented by a wl_surface, for implementations that
//! provide a desktop-style user interface. it provides a base set of functionality
//! required to construct user interface elements requiring management by the
//! compositor, such as toplevel windows, menus, etc. the types of functionality are
//! split into xdg_surface roles. creating an xdg_surface does not set the role for
//! a wl_surface. in order to map an xdg_surface, the client must create a role-
//! specific object using, e.g., get_toplevel, get_popup. the wl_surface for any
//! given xdg_surface can have at most one role, and may not be assigned any role
//! not based on xdg_surface. a role must be assigned before any other requests are
//! made to the xdg_surface object. the client must call wl_surface.commit on the
//! corresponding wl_surface for the xdg_surface state to take effect. creating an
//! xdg_surface from a wl_surface which has a buffer attached or committed is a
//! client error, and any attempts by a client to attach or manipulate a buffer
//! prior to the first xdg_surface.configure call must also be treated as errors.
//! after creating a role-specific object and setting it up, the client must perform
//! an initial commit without any buffer attached. the compositor will reply with an
//! xdg_surface.configure event. the client must acknowledge it and is then allowed
//! to attach a buffer to map the surface. mapping an xdg_surface-based role surface
//! is defined as making it possible for the surface to be shown by the compositor.
//! note that a mapped surface is not guaranteed to be visible once it is mapped.
//! for an xdg_surface to be mapped by the compositor, the following conditions must
//! be met: (1) the client has assigned an xdg_surface-based role to the surface (2)
//! the client has set and committed the xdg_surface state and the role-dependent
//! state to the surface (3) the client has committed a buffer to the surface a
//! newly-unmapped surface is considered to have met condition (1) out of the 3
//! required conditions for mapping a surface if its role surface has not been
//! destroyed.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;

use crate::wl::protocols::common::xdg_surface::*;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait XdgSurfaceExt {
    /// The configure event marks the end of a configure sequence. a configure sequence
    /// is a set of one or more events configuring the state of the xdg_surface,
    /// including the final xdg_surface.configure event. where applicable, xdg_surface
    /// surface roles will during a configure sequence extend this event as a latched
    /// state sent as events before the xdg_surface.configure event. such events should
    /// be considered to make up a set of atomically applied configuration states, where
    /// the xdg_surface.configure commits the accumulated state. clients should arrange
    /// their surface for the new states, and then send an ack_configure request with
    /// the serial sent in this configure event at some point before committing the new
    /// surface. if the client receives multiple configure events before it can respond
    /// to one, it is free to discard all but the last event it received.
    fn configure(&self, serial: u32) -> Result<(), SendError>;
}

impl XdgSurfaceExt for XdgSurface {
    /// The configure event marks the end of a configure sequence. a configure sequence
    /// is a set of one or more events configuring the state of the xdg_surface,
    /// including the final xdg_surface.configure event. where applicable, xdg_surface
    /// surface roles will during a configure sequence extend this event as a latched
    /// state sent as events before the xdg_surface.configure event. such events should
    /// be considered to make up a set of atomically applied configuration states, where
    /// the xdg_surface.configure commits the accumulated state. clients should arrange
    /// their surface for the new states, and then send an ack_configure request with
    /// the serial sent in this configure event at some point before committing the new
    /// surface. if the client receives multiple configure events before it can respond
    /// to one, it is free to discard all but the last event it received.
    fn configure(&self, serial: u32) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::Configure { serial }.into_raw(self.id()))
    }
}
