//! A seat is a group of keyboards, pointer and touch devices. this object is
//! published as a global during start up, or when such a device is hot plugged. a
//! seat typically has a pointer and maintains a keyboard focus and a pointer focus.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;

use crate::wl::protocols::common::wl_seat::*;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait WlSeatExt {
    /// This is emitted whenever a seat gains or loses the pointer, keyboard or touch
    /// capabilities. the argument is a capability enum containing the complete set of
    /// capabilities this seat has. when the pointer capability is added, a client may
    /// create a wl_pointer object using the wl_seat.get_pointer request. this object
    /// will receive pointer events until the capability is removed in the future. when
    /// the pointer capability is removed, a client should destroy the wl_pointer
    /// objects associated with the seat where the capability was removed, using the
    /// wl_pointer.release request. no further pointer events will be received on these
    /// objects. in some compositors, if a seat regains the pointer capability and a
    /// client has a previously obtained wl_pointer object of version 4 or less, that
    /// object may start sending pointer events again. this behavior is considered a
    /// misinterpretation of the intended behavior and must not be relied upon by the
    /// client. wl_pointer objects of version 5 or later must not send events if created
    /// before the most recent event notifying the client of an added pointer
    /// capability. the above behavior also applies to wl_keyboard and wl_touch with the
    /// keyboard and touch capabilities, respectively.
    fn capabilities(&self, capabilities: Capability) -> Result<(), SendError>;
    /// In a multiseat configuration this can be used by the client to help identify
    /// which physical devices the seat represents. based on the seat configuration used
    /// by the compositor.
    fn name(&self, name: String) -> Result<(), SendError>;
}

impl WlSeatExt for WlSeat {
    /// This is emitted whenever a seat gains or loses the pointer, keyboard or touch
    /// capabilities. the argument is a capability enum containing the complete set of
    /// capabilities this seat has. when the pointer capability is added, a client may
    /// create a wl_pointer object using the wl_seat.get_pointer request. this object
    /// will receive pointer events until the capability is removed in the future. when
    /// the pointer capability is removed, a client should destroy the wl_pointer
    /// objects associated with the seat where the capability was removed, using the
    /// wl_pointer.release request. no further pointer events will be received on these
    /// objects. in some compositors, if a seat regains the pointer capability and a
    /// client has a previously obtained wl_pointer object of version 4 or less, that
    /// object may start sending pointer events again. this behavior is considered a
    /// misinterpretation of the intended behavior and must not be relied upon by the
    /// client. wl_pointer objects of version 5 or later must not send events if created
    /// before the most recent event notifying the client of an added pointer
    /// capability. the above behavior also applies to wl_keyboard and wl_touch with the
    /// keyboard and touch capabilities, respectively.
    fn capabilities(&self, capabilities: Capability) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::Capabilities { capabilities }.into_raw(self.id()))
    }
    /// In a multiseat configuration this can be used by the client to help identify
    /// which physical devices the seat represents. based on the seat configuration used
    /// by the compositor.
    fn name(&self, name: String) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::Name { name }.into_raw(self.id()))
    }
}
