//! A buffer provides the content for a wl_surface. buffers are created through
//! factory interfaces such as wl_drm, wl_shm or similar. it has a width and a
//! height and can be attached to a wl_surface, but the mechanism by which a client
//! provides and updates the contents is defined by the buffer factory interface.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::*;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait WlBufferExt {
    /// Sent when this wl_buffer is no longer used by the compositor. the client is now
    /// free to reuse or destroy this buffer and its backing storage. if a client
    /// receives a release event before the frame callback requested in the same
    /// wl_surface.commit that attaches this wl_buffer to a surface, then the client is
    /// immediately free to reuse the buffer and its backing storage, and does not need
    /// a second buffer for the next surface content update. typically this is possible,
    /// when the compositor maintains a copy of the wl_surface contents, e.g. as a gl
    /// texture. this is an important optimization for gl(es) compositors with wl_shm
    /// clients.
    fn release(&self) -> Result<(), SendError>;
}

impl WlBufferExt for WlBuffer {
    /// Sent when this wl_buffer is no longer used by the compositor. the client is now
    /// free to reuse or destroy this buffer and its backing storage. if a client
    /// receives a release event before the frame callback requested in the same
    /// wl_surface.commit that attaches this wl_buffer to a surface, then the client is
    /// immediately free to reuse the buffer and its backing storage, and does not need
    /// a second buffer for the next surface content update. typically this is possible,
    /// when the compositor maintains a copy of the wl_surface contents, e.g. as a gl
    /// texture. this is an important optimization for gl(es) compositors with wl_shm
    /// clients.
    fn release(&self) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::Release {}.into_raw(self.id()))
    }
}
