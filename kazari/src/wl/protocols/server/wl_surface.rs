//! A surface is a rectangular area that may be displayed on zero or more outputs,
//! and shown any number of times at the compositor's discretion. they can present
//! wl_buffers, receive user input, and define a local coordinate system. the size
//! of a surface (and relative positions on it) is described in surface-local
//! coordinates, which may differ from the buffer coordinates of the pixel content,
//! in case a buffer_transform or a buffer_scale is used. a surface without a "role"
//! is fairly useless: a compositor does not know where, when or how to present it.
//! the role is the purpose of a wl_surface. examples of roles are a cursor for a
//! pointer (as set by wl_pointer.set_cursor), a drag icon
//! (wl_data_device.start_drag), a sub-surface (wl_subcompositor.get_subsurface),
//! and a window as defined by a shell protocol (e.g. wl_shell.get_shell_surface). a
//! surface can have only one role at a time. initially a wl_surface does not have a
//! role. once a wl_surface is given a role, it is set permanently for the whole
//! lifetime of the wl_surface object. giving the current role again is allowed,
//! unless explicitly forbidden by the relevant interface specification. surface
//! roles are given by requests in other interfaces such as wl_pointer.set_cursor.
//! the request should explicitly mention that this request gives a role to a
//! wl_surface. often, this request also creates a new protocol object that
//! represents the role and adds additional functionality to wl_surface. when a
//! client wants to destroy a wl_surface, they must destroy this 'role object'
//! before the wl_surface. destroying the role object does not remove the role from
//! the wl_surface, but it may stop the wl_surface from "playing the role". for
//! instance, if a wl_subsurface object is destroyed, the wl_surface it was created
//! for will be unmapped and forget its position and z-order. it is allowed to
//! create a wl_subsurface for the same wl_surface again, but it is not allowed to
//! use the wl_surface as a cursor (cursor is a different role than sub-surface, and
//! role switching is not allowed).

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;

use crate::wl::protocols::common::wl_surface::*;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait WlSurfaceExt {
    /// This is emitted whenever a surface's creation, movement, or resizing results in
    /// some part of it being within the scanout region of an output. note that a
    /// surface may be overlapping with zero or more outputs.
    fn enter(&self, output: WlOutput) -> Result<(), SendError>;
    /// This is emitted whenever a surface's creation, movement, or resizing results in
    /// it no longer having any part of it within the scanout region of an output.
    /// clients should not use the number of outputs the surface is on for frame
    /// throttling purposes. the surface might be hidden even if no leave event has been
    /// sent, and the compositor might expect new surface content updates even if no
    /// enter event has been sent. the frame event should be used instead.
    fn leave(&self, output: WlOutput) -> Result<(), SendError>;
}

impl WlSurfaceExt for WlSurface {
    /// This is emitted whenever a surface's creation, movement, or resizing results in
    /// some part of it being within the scanout region of an output. note that a
    /// surface may be overlapping with zero or more outputs.
    fn enter(&self, output: WlOutput) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::Enter { output }.into_raw(self.id()))
    }
    /// This is emitted whenever a surface's creation, movement, or resizing results in
    /// it no longer having any part of it within the scanout region of an output.
    /// clients should not use the number of outputs the surface is on for frame
    /// throttling purposes. the surface might be hidden even if no leave event has been
    /// sent, and the compositor might expect new surface content updates even if no
    /// enter event has been sent. the frame event should be used instead.
    fn leave(&self, output: WlOutput) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::Leave { output }.into_raw(self.id()))
    }
}
