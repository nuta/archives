//! The core global object. this is a special singleton object. it is used for
//! internal wayland protocol features.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;

use crate::wl::protocols::common::wl_display::*;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait WlDisplayExt {
    /// The error event is sent out when a fatal (non-recoverable) error has occurred.
    /// the object_id argument is the object where the error occurred, most often in
    /// response to a request to that object. the code identifies the error and is
    /// defined by the object interface. as such, each interface defines its own set of
    /// error codes. the message is a brief description of the error, for (debugging)
    /// convenience.
    fn error(&self, object_id: ObjectId, code: u32, message: String) -> Result<(), SendError>;
    /// This event is used internally by the object id management logic. when a client
    /// deletes an object that it had created, the server will send this event to
    /// acknowledge that it has seen the delete request. when the client receives this
    /// event, it will know that it can safely reuse the object id.
    fn delete_id(&self, id: u32) -> Result<(), SendError>;
}

impl WlDisplayExt for WlDisplay {
    /// The error event is sent out when a fatal (non-recoverable) error has occurred.
    /// the object_id argument is the object where the error occurred, most often in
    /// response to a request to that object. the code identifies the error and is
    /// defined by the object interface. as such, each interface defines its own set of
    /// error codes. the message is a brief description of the error, for (debugging)
    /// convenience.
    fn error(&self, object_id: ObjectId, code: u32, message: String) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Event::Error {
                object_id,
                code,
                message,
            }
            .into_raw(self.id()),
        )
    }
    /// This event is used internally by the object id management logic. when a client
    /// deletes an object that it had created, the server will send this event to
    /// acknowledge that it has seen the delete request. when the client receives this
    /// event, it will know that it can safely reuse the object id.
    fn delete_id(&self, id: u32) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Event::DeleteId { id }.into_raw(self.id()))
    }
}
