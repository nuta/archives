//! The xdg_positioner provides a collection of rules for the placement of a child
//! surface relative to a parent surface. rules can be defined to ensure the child
//! surface remains within the visible area's borders, and to specify how the child
//! surface changes its position, such as sliding along an axis, or flipping around
//! a rectangle. these positioner-created rules are constrained by the requirement
//! that a child surface must intersect with or be at least partially adjacent to
//! its parent surface. see the various requests for details about possible rules.
//! at the time of the request, the compositor makes a copy of the rules specified
//! by the xdg_positioner. thus, after the request is complete the xdg_positioner
//! object can be destroyed or reused; further changes to the object will have no
//! effect on previous usages. for an xdg_positioner object to be considered
//! complete, it must have a non-zero size set by set_size, and a non-zero anchor
//! rectangle set by set_anchor_rect. passing an incomplete xdg_positioner object
//! when positioning a surface raises an error.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;

use crate::wl::protocols::common::xdg_positioner::*;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait XdgPositionerExt {
    /// Notify the compositor that the xdg_positioner will no longer be used.
    fn destroy(&self) -> Result<(), SendError>;
    /// Set the size of the surface that is to be positioned with the positioner object.
    /// the size is in surface-local coordinates and corresponds to the window geometry.
    /// see xdg_surface.set_window_geometry. if a zero or negative size is set the
    /// invalid_input error is raised.
    fn set_size(&self, width: i32, height: i32) -> Result<(), SendError>;
    /// Specify the anchor rectangle within the parent surface that the child surface
    /// will be placed relative to. the rectangle is relative to the window geometry as
    /// defined by xdg_surface.set_window_geometry of the parent surface. when the
    /// xdg_positioner object is used to position a child surface, the anchor rectangle
    /// may not extend outside the window geometry of the positioned child's parent
    /// surface. if a negative size is set the invalid_input error is raised.
    fn set_anchor_rect(&self, x: i32, y: i32, width: i32, height: i32) -> Result<(), SendError>;
    /// Defines the anchor point for the anchor rectangle. the specified anchor is used
    /// derive an anchor point that the child surface will be positioned relative to. if
    /// a corner anchor is set (e.g. 'top_left' or 'bottom_right'), the anchor point
    /// will be at the specified corner; otherwise, the derived anchor point will be
    /// centered on the specified edge, or in the center of the anchor rectangle if no
    /// edge is specified.
    fn set_anchor(&self, anchor: Anchor) -> Result<(), SendError>;
    /// Defines in what direction a surface should be positioned, relative to the anchor
    /// point of the parent surface. if a corner gravity is specified (e.g.
    /// 'bottom_right' or 'top_left'), then the child surface will be placed towards the
    /// specified gravity; otherwise, the child surface will be centered over the anchor
    /// point on any axis that had no gravity specified.
    fn set_gravity(&self, gravity: Gravity) -> Result<(), SendError>;
    /// Specify how the window should be positioned if the originally intended position
    /// caused the surface to be constrained, meaning at least partially outside
    /// positioning boundaries set by the compositor. the adjustment is set by
    /// constructing a bitmask describing the adjustment to be made when the surface is
    /// constrained on that axis. if no bit for one axis is set, the compositor will
    /// assume that the child surface should not change its position on that axis when
    /// constrained. if more than one bit for one axis is set, the order of how
    /// adjustments are applied is specified in the corresponding adjustment
    /// descriptions. the default adjustment is none.
    fn set_constraint_adjustment(&self, constraint_adjustment: u32) -> Result<(), SendError>;
    /// Specify the surface position offset relative to the position of the anchor on
    /// the anchor rectangle and the anchor on the surface. for example if the anchor of
    /// the anchor rectangle is at (x, y), the surface has the gravity bottom|right, and
    /// the offset is (ox, oy), the calculated surface position will be (x + ox, y +
    /// oy). the offset position of the surface is the one used for constraint testing.
    /// see set_constraint_adjustment. an example use case is placing a popup menu on
    /// top of a user interface element, while aligning the user interface element of
    /// the parent surface with some user interface element placed somewhere in the
    /// popup surface.
    fn set_offset(&self, x: i32, y: i32) -> Result<(), SendError>;
    /// When set reactive, the surface is reconstrained if the conditions used for
    /// constraining changed, e.g. the parent window moved. if the conditions changed
    /// and the popup was reconstrained, an xdg_popup.configure event is sent with
    /// updated geometry, followed by an xdg_surface.configure event.
    fn set_reactive(&self) -> Result<(), SendError>;
    /// Set the parent window geometry the compositor should use when positioning the
    /// popup. the compositor may use this information to determine the future state the
    /// popup should be constrained using. if this doesn't match the dimension of the
    /// parent the popup is eventually positioned against, the behavior is undefined.
    /// the arguments are given in the surface-local coordinate space.
    fn set_parent_size(&self, parent_width: i32, parent_height: i32) -> Result<(), SendError>;
    /// Set the serial of an xdg_surface.configure event this positioner will be used in
    /// response to. the compositor may use this information together with
    /// set_parent_size to determine what future state the popup should be constrained
    /// using.
    fn set_parent_configure(&self, serial: u32) -> Result<(), SendError>;
}

impl XdgPositionerExt for XdgPositioner {
    /// Notify the compositor that the xdg_positioner will no longer be used.
    fn destroy(&self) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::Destroy {}.into_raw(self.id()))
    }
    /// Set the size of the surface that is to be positioned with the positioner object.
    /// the size is in surface-local coordinates and corresponds to the window geometry.
    /// see xdg_surface.set_window_geometry. if a zero or negative size is set the
    /// invalid_input error is raised.
    fn set_size(&self, width: i32, height: i32) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::SetSize { width, height }.into_raw(self.id()))
    }
    /// Specify the anchor rectangle within the parent surface that the child surface
    /// will be placed relative to. the rectangle is relative to the window geometry as
    /// defined by xdg_surface.set_window_geometry of the parent surface. when the
    /// xdg_positioner object is used to position a child surface, the anchor rectangle
    /// may not extend outside the window geometry of the positioned child's parent
    /// surface. if a negative size is set the invalid_input error is raised.
    fn set_anchor_rect(&self, x: i32, y: i32, width: i32, height: i32) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Request::SetAnchorRect {
                x,
                y,
                width,
                height,
            }
            .into_raw(self.id()),
        )
    }
    /// Defines the anchor point for the anchor rectangle. the specified anchor is used
    /// derive an anchor point that the child surface will be positioned relative to. if
    /// a corner anchor is set (e.g. 'top_left' or 'bottom_right'), the anchor point
    /// will be at the specified corner; otherwise, the derived anchor point will be
    /// centered on the specified edge, or in the center of the anchor rectangle if no
    /// edge is specified.
    fn set_anchor(&self, anchor: Anchor) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::SetAnchor { anchor }.into_raw(self.id()))
    }
    /// Defines in what direction a surface should be positioned, relative to the anchor
    /// point of the parent surface. if a corner gravity is specified (e.g.
    /// 'bottom_right' or 'top_left'), then the child surface will be placed towards the
    /// specified gravity; otherwise, the child surface will be centered over the anchor
    /// point on any axis that had no gravity specified.
    fn set_gravity(&self, gravity: Gravity) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::SetGravity { gravity }.into_raw(self.id()))
    }
    /// Specify how the window should be positioned if the originally intended position
    /// caused the surface to be constrained, meaning at least partially outside
    /// positioning boundaries set by the compositor. the adjustment is set by
    /// constructing a bitmask describing the adjustment to be made when the surface is
    /// constrained on that axis. if no bit for one axis is set, the compositor will
    /// assume that the child surface should not change its position on that axis when
    /// constrained. if more than one bit for one axis is set, the order of how
    /// adjustments are applied is specified in the corresponding adjustment
    /// descriptions. the default adjustment is none.
    fn set_constraint_adjustment(&self, constraint_adjustment: u32) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Request::SetConstraintAdjustment {
                constraint_adjustment,
            }
            .into_raw(self.id()),
        )
    }
    /// Specify the surface position offset relative to the position of the anchor on
    /// the anchor rectangle and the anchor on the surface. for example if the anchor of
    /// the anchor rectangle is at (x, y), the surface has the gravity bottom|right, and
    /// the offset is (ox, oy), the calculated surface position will be (x + ox, y +
    /// oy). the offset position of the surface is the one used for constraint testing.
    /// see set_constraint_adjustment. an example use case is placing a popup menu on
    /// top of a user interface element, while aligning the user interface element of
    /// the parent surface with some user interface element placed somewhere in the
    /// popup surface.
    fn set_offset(&self, x: i32, y: i32) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::SetOffset { x, y }.into_raw(self.id()))
    }
    /// When set reactive, the surface is reconstrained if the conditions used for
    /// constraining changed, e.g. the parent window moved. if the conditions changed
    /// and the popup was reconstrained, an xdg_popup.configure event is sent with
    /// updated geometry, followed by an xdg_surface.configure event.
    fn set_reactive(&self) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::SetReactive {}.into_raw(self.id()))
    }
    /// Set the parent window geometry the compositor should use when positioning the
    /// popup. the compositor may use this information to determine the future state the
    /// popup should be constrained using. if this doesn't match the dimension of the
    /// parent the popup is eventually positioned against, the behavior is undefined.
    /// the arguments are given in the surface-local coordinate space.
    fn set_parent_size(&self, parent_width: i32, parent_height: i32) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Request::SetParentSize {
                parent_width,
                parent_height,
            }
            .into_raw(self.id()),
        )
    }
    /// Set the serial of an xdg_surface.configure event this positioner will be used in
    /// response to. the compositor may use this information together with
    /// set_parent_size to determine what future state the popup should be constrained
    /// using.
    fn set_parent_configure(&self, serial: u32) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::SetParentConfigure { serial }.into_raw(self.id()))
    }
}
