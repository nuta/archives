//! The wl_shm_pool object encapsulates a piece of memory shared between the
//! compositor and client. through the wl_shm_pool object, the client can allocate
//! shared memory wl_buffer objects. all objects created through the same pool share
//! the same underlying mapped memory. reusing the mapped memory avoids the
//! setup/teardown overhead and is useful when interactively resizing a surface or
//! for many small buffers.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;

use crate::wl::protocols::common::wl_shm_pool::*;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait WlShmPoolExt {
    /// Create a wl_buffer object from the pool. the buffer is created offset bytes into
    /// the pool and has width and height as specified. the stride argument specifies
    /// the number of bytes from the beginning of one row to the beginning of the next.
    /// the format is the pixel format of the buffer and must be one of those advertised
    /// through the wl_shm.format event. a buffer will keep a reference to the pool it
    /// was created from so it is valid to destroy the pool immediately after creating a
    /// buffer from it.
    fn create_buffer(
        &self,
        id: NewId,
        offset: i32,
        width: i32,
        height: i32,
        stride: i32,
        format: super::super::common::wl_shm::Format,
    ) -> Result<(), SendError>;
    /// Destroy the shared memory pool. the mmapped memory will be released when all
    /// buffers that have been created from this pool are gone.
    fn destroy(&self) -> Result<(), SendError>;
    /// This request will cause the server to remap the backing memory for the pool from
    /// the file descriptor passed when the pool was created, but using the new size.
    /// this request can only be used to make the pool bigger.
    fn resize(&self, size: i32) -> Result<(), SendError>;
}

impl WlShmPoolExt for WlShmPool {
    /// Create a wl_buffer object from the pool. the buffer is created offset bytes into
    /// the pool and has width and height as specified. the stride argument specifies
    /// the number of bytes from the beginning of one row to the beginning of the next.
    /// the format is the pixel format of the buffer and must be one of those advertised
    /// through the wl_shm.format event. a buffer will keep a reference to the pool it
    /// was created from so it is valid to destroy the pool immediately after creating a
    /// buffer from it.
    fn create_buffer(
        &self,
        id: NewId,
        offset: i32,
        width: i32,
        height: i32,
        stride: i32,
        format: super::super::common::wl_shm::Format,
    ) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Request::CreateBuffer {
                id,
                offset,
                width,
                height,
                stride,
                format,
            }
            .into_raw(self.id()),
        )
    }
    /// Destroy the shared memory pool. the mmapped memory will be released when all
    /// buffers that have been created from this pool are gone.
    fn destroy(&self) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::Destroy {}.into_raw(self.id()))
    }
    /// This request will cause the server to remap the backing memory for the pool from
    /// the file descriptor passed when the pool was created, but using the new size.
    /// this request can only be used to make the pool bigger.
    fn resize(&self, size: i32) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::Resize { size }.into_raw(self.id()))
    }
}
