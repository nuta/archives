//! The wl_pointer interface represents one or more input devices, such as mice,
//! which control the pointer location and pointer_focus of a seat. the wl_pointer
//! interface generates motion, enter and leave events for the surfaces that the
//! pointer is located over, and button and axis events for button presses, button
//! releases and scrolling.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;

use crate::wl::protocols::common::wl_pointer::*;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait WlPointerExt {
    /// Set the pointer surface, i.e., the surface that contains the pointer image
    /// (cursor). this request gives the surface the role of a cursor. if the surface
    /// already has another role, it raises a protocol error. the cursor actually
    /// changes only if the pointer focus for this device is one of the requesting
    /// client's surfaces or the surface parameter is the current pointer surface. if
    /// there was a previous surface set with this request it is replaced. if surface is
    /// null, the pointer image is hidden. the parameters hotspot_x and hotspot_y define
    /// the position of the pointer surface relative to the pointer location. its top-
    /// left corner is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
    /// coordinates of the pointer location, in surface-local coordinates. on
    /// surface.attach requests to the pointer surface, hotspot_x and hotspot_y are
    /// decremented by the x and y parameters passed to the request. attach must be
    /// confirmed by wl_surface.commit as usual. the hotspot can also be updated by
    /// passing the currently set pointer surface to this request with new values for
    /// hotspot_x and hotspot_y. the current and pending input regions of the wl_surface
    /// are cleared, and wl_surface.set_input_region is ignored until the wl_surface is
    /// no longer used as the cursor. when the use as a cursor ends, the current and
    /// pending input regions become undefined, and the wl_surface is unmapped.
    fn set_cursor(
        &self,
        serial: u32,
        surface: Option<WlSurface>,
        hotspot_x: i32,
        hotspot_y: i32,
    ) -> Result<(), SendError>;
    /// Using this request a client can tell the server that it is not going to use the
    /// pointer object anymore. this request destroys the pointer proxy object, so
    /// clients must not call wl_pointer_destroy() after using this request.
    fn release(&self) -> Result<(), SendError>;
}

impl WlPointerExt for WlPointer {
    /// Set the pointer surface, i.e., the surface that contains the pointer image
    /// (cursor). this request gives the surface the role of a cursor. if the surface
    /// already has another role, it raises a protocol error. the cursor actually
    /// changes only if the pointer focus for this device is one of the requesting
    /// client's surfaces or the surface parameter is the current pointer surface. if
    /// there was a previous surface set with this request it is replaced. if surface is
    /// null, the pointer image is hidden. the parameters hotspot_x and hotspot_y define
    /// the position of the pointer surface relative to the pointer location. its top-
    /// left corner is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the
    /// coordinates of the pointer location, in surface-local coordinates. on
    /// surface.attach requests to the pointer surface, hotspot_x and hotspot_y are
    /// decremented by the x and y parameters passed to the request. attach must be
    /// confirmed by wl_surface.commit as usual. the hotspot can also be updated by
    /// passing the currently set pointer surface to this request with new values for
    /// hotspot_x and hotspot_y. the current and pending input regions of the wl_surface
    /// are cleared, and wl_surface.set_input_region is ignored until the wl_surface is
    /// no longer used as the cursor. when the use as a cursor ends, the current and
    /// pending input regions become undefined, and the wl_surface is unmapped.
    fn set_cursor(
        &self,
        serial: u32,
        surface: Option<WlSurface>,
        hotspot_x: i32,
        hotspot_y: i32,
    ) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Request::SetCursor {
                serial,
                surface,
                hotspot_x,
                hotspot_y,
            }
            .into_raw(self.id()),
        )
    }
    /// Using this request a client can tell the server that it is not going to use the
    /// pointer object anymore. this request destroys the pointer proxy object, so
    /// clients must not call wl_pointer_destroy() after using this request.
    fn release(&self) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::Release {}.into_raw(self.id()))
    }
}
