//! There is one wl_data_device per seat which can be obtained from the global
//! wl_data_device_manager singleton. a wl_data_device provides access to inter-
//! client data transfer mechanisms such as copy-and-paste and drag-and-drop.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;

use crate::wl::protocols::common::wl_data_device::*;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;
use crate::wl::protocols::common::wl_shell_surface::WlShellSurface;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait WlDataDeviceExt {
    /// This request asks the compositor to start a drag-and-drop operation on behalf of
    /// the client. the source argument is the data source that provides the data for
    /// the eventual data transfer. if source is null, enter, leave and motion events
    /// are sent only to the client that initiated the drag and the client is expected
    /// to handle the data passing internally. if source is destroyed, the drag-and-drop
    /// session will be cancelled. the origin surface is the surface where the drag
    /// originates and the client must have an active implicit grab that matches the
    /// serial. the icon surface is an optional (can be null) surface that provides an
    /// icon to be moved around with the cursor. initially, the top-left corner of the
    /// icon surface is placed at the cursor hotspot, but subsequent wl_surface.attach
    /// request can move the relative position. attach requests must be confirmed with
    /// wl_surface.commit as usual. the icon surface is given the role of a drag-and-
    /// drop icon. if the icon surface already has another role, it raises a protocol
    /// error. the current and pending input regions of the icon wl_surface are cleared,
    /// and wl_surface.set_input_region is ignored until the wl_surface is no longer
    /// used as the icon surface. when the use as an icon ends, the current and pending
    /// input regions become undefined, and the wl_surface is unmapped.
    fn start_drag(
        &self,
        source: Option<WlDataSource>,
        origin: WlSurface,
        icon: Option<WlSurface>,
        serial: u32,
    ) -> Result<(), SendError>;
    /// This request asks the compositor to set the selection to the data from the
    /// source on behalf of the client. to unset the selection, set the source to null.
    fn set_selection(&self, source: Option<WlDataSource>, serial: u32) -> Result<(), SendError>;
    /// This request destroys the data device.
    fn release(&self) -> Result<(), SendError>;
}

impl WlDataDeviceExt for WlDataDevice {
    /// This request asks the compositor to start a drag-and-drop operation on behalf of
    /// the client. the source argument is the data source that provides the data for
    /// the eventual data transfer. if source is null, enter, leave and motion events
    /// are sent only to the client that initiated the drag and the client is expected
    /// to handle the data passing internally. if source is destroyed, the drag-and-drop
    /// session will be cancelled. the origin surface is the surface where the drag
    /// originates and the client must have an active implicit grab that matches the
    /// serial. the icon surface is an optional (can be null) surface that provides an
    /// icon to be moved around with the cursor. initially, the top-left corner of the
    /// icon surface is placed at the cursor hotspot, but subsequent wl_surface.attach
    /// request can move the relative position. attach requests must be confirmed with
    /// wl_surface.commit as usual. the icon surface is given the role of a drag-and-
    /// drop icon. if the icon surface already has another role, it raises a protocol
    /// error. the current and pending input regions of the icon wl_surface are cleared,
    /// and wl_surface.set_input_region is ignored until the wl_surface is no longer
    /// used as the icon surface. when the use as an icon ends, the current and pending
    /// input regions become undefined, and the wl_surface is unmapped.
    fn start_drag(
        &self,
        source: Option<WlDataSource>,
        origin: WlSurface,
        icon: Option<WlSurface>,
        serial: u32,
    ) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Request::StartDrag {
                source,
                origin,
                icon,
                serial,
            }
            .into_raw(self.id()),
        )
    }
    /// This request asks the compositor to set the selection to the data from the
    /// source on behalf of the client. to unset the selection, set the source to null.
    fn set_selection(&self, source: Option<WlDataSource>, serial: u32) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::SetSelection { source, serial }.into_raw(self.id()))
    }
    /// This request destroys the data device.
    fn release(&self) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::Release {}.into_raw(self.id()))
    }
}
