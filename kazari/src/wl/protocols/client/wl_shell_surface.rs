//! An interface that may be implemented by a wl_surface, for implementations that
//! provide a desktop-style user interface. it provides requests to treat surfaces
//! like toplevel, fullscreen or popup windows, move, resize or maximize them,
//! associate metadata like title and class, etc. on the server side the object is
//! automatically destroyed when the related wl_surface is destroyed. on the client
//! side, wl_shell_surface_destroy() must be called before destroying the wl_surface
//! object.

//
//
//              GENERATED BY OUR WAYLAND-SCANNER. DO NOT EDIT!
//
//

#![allow(unused)]
#![allow(clippy::from_over_into)]
#![allow(clippy::match_single_binding)]

use crate::wl::{
    Array, Connection, Handle, Interface, Message, NewId, ObjectId, Opcode, Payload, PayloadType,
    RawMessage, SendError,
};
use alloc::rc::Rc;
use alloc::string::String;
use core::cell::RefCell;
use smallvec::smallvec;

use crate::wl::protocols::common::wl_buffer::WlBuffer;
use crate::wl::protocols::common::wl_callback::WlCallback;
use crate::wl::protocols::common::wl_compositor::WlCompositor;
use crate::wl::protocols::common::wl_data_device::WlDataDevice;
use crate::wl::protocols::common::wl_data_device_manager::WlDataDeviceManager;
use crate::wl::protocols::common::wl_data_offer::WlDataOffer;
use crate::wl::protocols::common::wl_data_source::WlDataSource;
use crate::wl::protocols::common::wl_display::WlDisplay;
use crate::wl::protocols::common::wl_keyboard::WlKeyboard;
use crate::wl::protocols::common::wl_output::WlOutput;
use crate::wl::protocols::common::wl_pointer::WlPointer;
use crate::wl::protocols::common::wl_region::WlRegion;
use crate::wl::protocols::common::wl_registry::WlRegistry;
use crate::wl::protocols::common::wl_seat::WlSeat;
use crate::wl::protocols::common::wl_shell::WlShell;

use crate::wl::protocols::common::wl_shell_surface::*;
use crate::wl::protocols::common::wl_shm::WlShm;
use crate::wl::protocols::common::wl_shm_pool::WlShmPool;
use crate::wl::protocols::common::wl_subcompositor::WlSubcompositor;
use crate::wl::protocols::common::wl_subsurface::WlSubsurface;
use crate::wl::protocols::common::wl_surface::WlSurface;
use crate::wl::protocols::common::wl_touch::WlTouch;
use crate::wl::protocols::common::xdg_popup::XdgPopup;
use crate::wl::protocols::common::xdg_positioner::XdgPositioner;
use crate::wl::protocols::common::xdg_surface::XdgSurface;
use crate::wl::protocols::common::xdg_toplevel::XdgToplevel;
use crate::wl::protocols::common::xdg_wm_base::XdgWmBase;

pub trait WlShellSurfaceExt {
    /// A client must respond to a ping event with a pong request or the client may be
    /// deemed unresponsive.
    fn pong(&self, serial: u32) -> Result<(), SendError>;
    /// Start a pointer-driven move of the surface. this request must be used in
    /// response to a button press event. the server may ignore move requests depending
    /// on the state of the surface (e.g. fullscreen or maximized).
    fn move_(&self, seat: WlSeat, serial: u32) -> Result<(), SendError>;
    /// Start a pointer-driven resizing of the surface. this request must be used in
    /// response to a button press event. the server may ignore resize requests
    /// depending on the state of the surface (e.g. fullscreen or maximized).
    fn resize(&self, seat: WlSeat, serial: u32, edges: Resize) -> Result<(), SendError>;
    /// Map the surface as a toplevel surface. a toplevel surface is not fullscreen,
    /// maximized or transient.
    fn set_toplevel(&self) -> Result<(), SendError>;
    /// Map the surface relative to an existing surface. the x and y arguments specify
    /// the location of the upper left corner of the surface relative to the upper left
    /// corner of the parent surface, in surface-local coordinates. the flags argument
    /// controls details of the transient behaviour.
    fn set_transient(
        &self,
        parent: WlSurface,
        x: i32,
        y: i32,
        flags: Transient,
    ) -> Result<(), SendError>;
    /// Map the surface as a fullscreen surface. if an output parameter is given then
    /// the surface will be made fullscreen on that output. if the client does not
    /// specify the output then the compositor will apply its policy - usually choosing
    /// the output on which the surface has the biggest surface area. the client may
    /// specify a method to resolve a size conflict between the output size and the
    /// surface size - this is provided through the method parameter. the framerate
    /// parameter is used only when the method is set to "driver", to indicate the
    /// preferred framerate. a value of 0 indicates that the client does not care about
    /// framerate. the framerate is specified in mhz, that is framerate of 60000 is
    /// 60hz. a method of "scale" or "driver" implies a scaling operation of the
    /// surface, either via a direct scaling operation or a change of the output mode.
    /// this will override any kind of output scaling, so that mapping a surface with a
    /// buffer size equal to the mode can fill the screen independent of buffer_scale. a
    /// method of "fill" means we don't scale up the buffer, however any output scale is
    /// applied. this means that you may run into an edge case where the application
    /// maps a buffer with the same size of the output mode but buffer_scale 1 (thus
    /// making a surface larger than the output). in this case it is allowed to
    /// downscale the results to fit the screen. the compositor must reply to this
    /// request with a configure event with the dimensions for the output on which the
    /// surface will be made fullscreen.
    fn set_fullscreen(
        &self,
        method: FullscreenMethod,
        framerate: u32,
        output: Option<WlOutput>,
    ) -> Result<(), SendError>;
    /// Map the surface as a popup. a popup surface is a transient surface with an added
    /// pointer grab. an existing implicit grab will be changed to owner-events mode,
    /// and the popup grab will continue after the implicit grab ends (i.e. releasing
    /// the mouse button does not cause the popup to be unmapped). the popup grab
    /// continues until the window is destroyed or a mouse button is pressed in any
    /// other client's window. a click in any of the client's surfaces is reported as
    /// normal, however, clicks in other clients' surfaces will be discarded and trigger
    /// the callback. the x and y arguments specify the location of the upper left
    /// corner of the surface relative to the upper left corner of the parent surface,
    /// in surface-local coordinates.
    fn set_popup(
        &self,
        seat: WlSeat,
        serial: u32,
        parent: WlSurface,
        x: i32,
        y: i32,
        flags: Transient,
    ) -> Result<(), SendError>;
    /// Map the surface as a maximized surface. if an output parameter is given then the
    /// surface will be maximized on that output. if the client does not specify the
    /// output then the compositor will apply its policy - usually choosing the output
    /// on which the surface has the biggest surface area. the compositor will reply
    /// with a configure event telling the expected new surface size. the operation is
    /// completed on the next buffer attach to this surface. a maximized surface
    /// typically fills the entire output it is bound to, except for desktop elements
    /// such as panels. this is the main difference between a maximized shell surface
    /// and a fullscreen shell surface. the details depend on the compositor
    /// implementation.
    fn set_maximized(&self, output: Option<WlOutput>) -> Result<(), SendError>;
    /// Set a short title for the surface. this string may be used to identify the
    /// surface in a task bar, window list, or other user interface elements provided by
    /// the compositor. the string must be encoded in utf-8.
    fn set_title(&self, title: String) -> Result<(), SendError>;
    /// Set a class for the surface. the surface class identifies the general class of
    /// applications to which the surface belongs. a common convention is to use the
    /// file name (or the full path if it is a non-standard location) of the
    /// application's .desktop file as the class.
    fn set_class(&self, class_: String) -> Result<(), SendError>;
}

impl WlShellSurfaceExt for WlShellSurface {
    /// A client must respond to a ping event with a pong request or the client may be
    /// deemed unresponsive.
    fn pong(&self, serial: u32) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::Pong { serial }.into_raw(self.id()))
    }
    /// Start a pointer-driven move of the surface. this request must be used in
    /// response to a button press event. the server may ignore move requests depending
    /// on the state of the surface (e.g. fullscreen or maximized).
    fn move_(&self, seat: WlSeat, serial: u32) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::Move { seat, serial }.into_raw(self.id()))
    }
    /// Start a pointer-driven resizing of the surface. this request must be used in
    /// response to a button press event. the server may ignore resize requests
    /// depending on the state of the surface (e.g. fullscreen or maximized).
    fn resize(&self, seat: WlSeat, serial: u32, edges: Resize) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Request::Resize {
                seat,
                serial,
                edges,
            }
            .into_raw(self.id()),
        )
    }
    /// Map the surface as a toplevel surface. a toplevel surface is not fullscreen,
    /// maximized or transient.
    fn set_toplevel(&self) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::SetToplevel {}.into_raw(self.id()))
    }
    /// Map the surface relative to an existing surface. the x and y arguments specify
    /// the location of the upper left corner of the surface relative to the upper left
    /// corner of the parent surface, in surface-local coordinates. the flags argument
    /// controls details of the transient behaviour.
    fn set_transient(
        &self,
        parent: WlSurface,
        x: i32,
        y: i32,
        flags: Transient,
    ) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Request::SetTransient {
                parent,
                x,
                y,
                flags,
            }
            .into_raw(self.id()),
        )
    }
    /// Map the surface as a fullscreen surface. if an output parameter is given then
    /// the surface will be made fullscreen on that output. if the client does not
    /// specify the output then the compositor will apply its policy - usually choosing
    /// the output on which the surface has the biggest surface area. the client may
    /// specify a method to resolve a size conflict between the output size and the
    /// surface size - this is provided through the method parameter. the framerate
    /// parameter is used only when the method is set to "driver", to indicate the
    /// preferred framerate. a value of 0 indicates that the client does not care about
    /// framerate. the framerate is specified in mhz, that is framerate of 60000 is
    /// 60hz. a method of "scale" or "driver" implies a scaling operation of the
    /// surface, either via a direct scaling operation or a change of the output mode.
    /// this will override any kind of output scaling, so that mapping a surface with a
    /// buffer size equal to the mode can fill the screen independent of buffer_scale. a
    /// method of "fill" means we don't scale up the buffer, however any output scale is
    /// applied. this means that you may run into an edge case where the application
    /// maps a buffer with the same size of the output mode but buffer_scale 1 (thus
    /// making a surface larger than the output). in this case it is allowed to
    /// downscale the results to fit the screen. the compositor must reply to this
    /// request with a configure event with the dimensions for the output on which the
    /// surface will be made fullscreen.
    fn set_fullscreen(
        &self,
        method: FullscreenMethod,
        framerate: u32,
        output: Option<WlOutput>,
    ) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Request::SetFullscreen {
                method,
                framerate,
                output,
            }
            .into_raw(self.id()),
        )
    }
    /// Map the surface as a popup. a popup surface is a transient surface with an added
    /// pointer grab. an existing implicit grab will be changed to owner-events mode,
    /// and the popup grab will continue after the implicit grab ends (i.e. releasing
    /// the mouse button does not cause the popup to be unmapped). the popup grab
    /// continues until the window is destroyed or a mouse button is pressed in any
    /// other client's window. a click in any of the client's surfaces is reported as
    /// normal, however, clicks in other clients' surfaces will be discarded and trigger
    /// the callback. the x and y arguments specify the location of the upper left
    /// corner of the surface relative to the upper left corner of the parent surface,
    /// in surface-local coordinates.
    fn set_popup(
        &self,
        seat: WlSeat,
        serial: u32,
        parent: WlSurface,
        x: i32,
        y: i32,
        flags: Transient,
    ) -> Result<(), SendError> {
        self.connection().borrow_mut().send(
            Request::SetPopup {
                seat,
                serial,
                parent,
                x,
                y,
                flags,
            }
            .into_raw(self.id()),
        )
    }
    /// Map the surface as a maximized surface. if an output parameter is given then the
    /// surface will be maximized on that output. if the client does not specify the
    /// output then the compositor will apply its policy - usually choosing the output
    /// on which the surface has the biggest surface area. the compositor will reply
    /// with a configure event telling the expected new surface size. the operation is
    /// completed on the next buffer attach to this surface. a maximized surface
    /// typically fills the entire output it is bound to, except for desktop elements
    /// such as panels. this is the main difference between a maximized shell surface
    /// and a fullscreen shell surface. the details depend on the compositor
    /// implementation.
    fn set_maximized(&self, output: Option<WlOutput>) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::SetMaximized { output }.into_raw(self.id()))
    }
    /// Set a short title for the surface. this string may be used to identify the
    /// surface in a task bar, window list, or other user interface elements provided by
    /// the compositor. the string must be encoded in utf-8.
    fn set_title(&self, title: String) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::SetTitle { title }.into_raw(self.id()))
    }
    /// Set a class for the surface. the surface class identifies the general class of
    /// applications to which the surface belongs. a common convention is to use the
    /// file name (or the full path if it is a non-standard location) of the
    /// application's .desktop file as the class.
    fn set_class(&self, class_: String) -> Result<(), SendError> {
        self.connection()
            .borrow_mut()
            .send(Request::SetClass { class_ }.into_raw(self.id()))
    }
}
